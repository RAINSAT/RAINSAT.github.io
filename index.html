<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hello, yxin" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="zhangyxin coder">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zhangyxin coder">
<meta property="article:author" content="zhangyxin">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> zhangyxin coder </title>
<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zhangyxin coder</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/16/http/" itemprop="url">
                  HTTP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-16T20:51:23+08:00">
                2020-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>HTTP 和 HTTPS 的区别</strong></p>
<p>HTTP 是一种 <code>超文本传输协议(Hypertext Transfer Protocol)</code>，<strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p>
<p><img src="https://ae03.alicdn.com/kf/He898ccf1d2b347a3bca60b286fc22f46W.png" alt="img"></p>
<p>HTTP 主要内容分为三部分，<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong>。</p>
<ul>
<li>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行<code>超链接</code>的跳转。</li>
<li>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为<code>请求方</code>，把接到二进制数据包的一方称为<code>应答方</code>。</li>
<li>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。</li>
</ul>
<p>说到 HTTP，不得不提的就是 TCP/IP 网络模型，一般是五层模型。如下图所示</p>
<p><img src="https://ae01.alicdn.com/kf/H2097a6c93412474c843440eee836cdc00.png" alt="img"></p>
<p>但是也可以分为四层，就是<strong>把链路层和物理层都表示为网络接口层</strong></p>
<p><img src="https://ae01.alicdn.com/kf/Hfc21c19a2e334e7ab579304d44514dfd5.png" alt="img"></p>
<p>还有一种就是 OSI 七层网络模型，它就是在五层协议之上加了<strong>表示层和会话层</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDvc1cQLtBePFFQOsiaQ3ApFgN8IicnibD8dCkpHY7oo39xJKRmBdnIneFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>而 HTTPS 的全称是 <code>Hypertext Transfer Protocol Secure</code>，从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。</p>
<p>也就是说，<strong>HTTPS 就是身披了一层 SSL 的 HTTP</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD19RoMWPIg8hv6BJZOaAle0qiclXjXBF4UUH9TWfjwmdibwP7EHssGqhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>那么，HTTP 和 HTTPS 的主要区别是什么呢？</p>
<ul>
<li>最简单的，HTTP 在地址栏上的协议是以 <code>http://</code> 开头，而 HTTPS 在地址栏上的协议是以 <code>https://</code> 开头</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cxuanblog.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.cxuanblog.com&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 <strong>密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法</strong> 能够解决上面这些问题。</li>
</ul>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<ul>
<li>HTTP 的默认端口是 <code>80</code>，而 HTTPS 的默认端口是 <code>443</code>。</li>
</ul>
<h2 id="HTTP-Get-和-Post-区别"><a href="#HTTP-Get-和-Post-区别" class="headerlink" title="HTTP Get 和 Post 区别"></a>HTTP Get 和 Post 区别</h2><p>HTTP 中包括许多方法，<strong>Get 和 Post 是 HTTP 中最常用的两个方法</strong>，基本上使用 HTTP 方法中有 99% 都是在使用 Get 方法和 Post 方法，所以有必要我们对这两个方法有更加深刻的认识。</p>
<ul>
<li><p>get 方法一般用于请求，比如你在浏览器地址栏输入 <code>www.baidu.com</code> 其实就是发送了一个 get 请求，它的主要特征是请求服务器返回资源，而 post 方法一般用于<code>表单</code>的提交，相当于是把信息提交给服务器，等待服务器作出响应，get 相当于一个是 pull/拉的操作，而 post 相当于是一个 push/推的操作。</p>
</li>
<li><p>get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure>

<p>而 post 方法是把参数放在请求体 body 中的，这对用户来说不可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test&#x2F;demo_form.asp HTTP&#x2F;1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure>

<ul>
<li>get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。</li>
<li>get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。</li>
<li>get 请求在浏览器反复的 <code>回退/前进</code> 操作是无害的，而 post 操作会再次提交表单请求。</li>
<li>get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</li>
</ul>
<h2 id="什么是无状态协议，HTTP-是无状态协议吗，怎么解决"><a href="#什么是无状态协议，HTTP-是无状态协议吗，怎么解决" class="headerlink" title="什么是无状态协议，HTTP 是无状态协议吗，怎么解决"></a>什么是无状态协议，HTTP 是无状态协议吗，怎么解决</h2><p><code>无状态协议(Stateless Protocol)</code> 就是指<strong>浏览器对于事务的处理没有记忆能力</strong>。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。</p>
<p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 <code>小甜饼(Cookie)</code> 的机制。它能够让浏览器具有<code>记忆</code>能力。</p>
<p>如果你的浏览器允许 cookie 的话，查看方式 <strong>chrome://settings/content/cookies</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDsCBfLLWyK87vklbxJHwlVkL8xicYPDIbW7VEfKjNCjS2YMnpP17ya6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>也就说明你的记忆芯片通电了…… 当你向服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 Set-Cookie：JSESSIONID=XXXXXXX 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 JSESSIONID=XXXXXXX 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDnLQ4cbMCZLF9ibM2km6nu7wyy0b9vZFq3L03vSG3omzRhncV68By8Ig/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDt4V7IRicwA7d9MIEdibHaxiaFBPaSKD2A3kuwxwM6micorkKJqiasj9AicaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>还有一种方式是使用 JWT 机制，它也是能够让你的浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点</p>
<ul>
<li>JWT 的 Cookie 信息存储在<code>客户端</code>，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。</li>
<li>JWT 支持跨域认证，Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</li>
</ul>
<h2 id="UDP-和-TCP-的区别"><a href="#UDP-和-TCP-的区别" class="headerlink" title="UDP 和 TCP 的区别"></a>UDP 和 TCP 的区别</h2><p>TCP 和 UDP 都位于计算机网络模型中的运输层，它们负责传输应用层产生的数据。</p>
<h3 id="UDP-是什么"><a href="#UDP-是什么" class="headerlink" title="UDP 是什么"></a>UDP 是什么</h3><p>UDP 的全称是 <code>User Datagram Protocol</code>，用户数据报协议。它不需要所谓的<code>握手</code>操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。</p>
<blockquote>
<p>数据报是与分组交换网络关联的传输单元。</p>
</blockquote>
<p>UDP 的特点主要有</p>
<ul>
<li>UDP 能够支持容忍数据包丢失的带宽密集型应用程序</li>
<li>UDP 具有低延迟的特点</li>
<li>UDP 能够发送大量的数据包</li>
<li>UDP 能够允许 DNS 查找，DNS 是建立在 UDP 之上的应用层协议。</li>
</ul>
<h3 id="TCP-是什么"><a href="#TCP-是什么" class="headerlink" title="TCP 是什么"></a>TCP 是什么</h3><p>TCP 的全称是<code>Transmission Control Protocol</code> ，传输控制协议。它能够帮助你确定计算机连接到 Internet 以及它们之间的数据传输。通过三次握手来建立 TCP 连接，三次握手就是用来启动和确认 TCP 连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。</p>
<p>TCP 的主要特点有</p>
<ul>
<li>TCP 能够确保连接的建立和数据包的发送</li>
<li>TCP 支持错误重传机制</li>
<li>TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送</li>
<li>TCP 能够提供错误校验和，甄别有害的数据包。</li>
</ul>
<h3 id="TCP-和-UDP-的不同"><a href="#TCP-和-UDP-的不同" class="headerlink" title="TCP 和 UDP 的不同"></a>TCP 和 UDP 的不同</h3><p><img src="https://ae01.alicdn.com/kf/H983cc78cdf264259903511ce82a470d1R.png" alt="img"></p>
<h2 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h2><p>TCP 三次握手和四次挥手也是面试题的热门考点，它们分别对应 TCP 的连接和释放过程。下面就来简单认识一下这两个过程</p>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>在了解具体的流程前，我们需要先认识几个概念</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD58Npf1AOxttKsHPFl4aOQ54Znzk6P3mic47cYsh2RLgQMibV4I8iaKbZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<ul>
<li>SYN：它的全称是 <code>Synchronize Sequence Numbers</code>，同步序列编号。是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立 TCP 连接时，首先会发送的一个信号。客户端在接受到 SYN 消息时，就会在自己的段内生成一个随机值 X。</li>
<li>SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。</li>
<li>ACK：<code>Acknowledge character</code>, 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDA1U4Yibbc99AU5HU3dv9A4WGuhdQHP4X1REia3oibJZevyDBKRictC58bQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>在连接终止阶段使用四次挥手，连接的每一端都会独立的终止。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDfa4qx2k7PGicQrGqVPIbqNbIxmbzEicT8F1mtgFbGfmxjGWlricibfgy1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<ul>
<li>首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将 FIN 发送到服务器，并进入 <code>FIN_WAIT_1</code> 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的 ACK 响应。</li>
<li>然后第二步，当服务器收到 FIN 消息时，服务器会立刻向客户端发送 ACK 确认消息。</li>
<li>当客户端收到服务器发送的 ACK 响应后，客户端就进入 <code>FIN_WAIT_2</code> 状态，然后等待来自服务器的 <code>FIN</code> 消息</li>
<li>服务器发送 ACK 确认消息后，一段时间（可以进行关闭后）会发送 FIN 消息给客户端，告知客户端可以进行关闭。</li>
<li>当客户端收到从服务端发送的 FIN 消息时，客户端就会由 FIN_WAIT_2 状态变为 <code>TIME_WAIT</code> 状态。处于 TIME_WAIT 状态的客户端允许重新发送 ACK 到服务器为了防止信息丢失。客户端在 TIME_WAIT 状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源（包括端口号和缓冲区数据）都被释放。</li>
</ul>
<h2 id="简述-HTTP1-0-1-1-2-0-的区别"><a href="#简述-HTTP1-0-1-1-2-0-的区别" class="headerlink" title="简述 HTTP1.0/1.1/2.0 的区别"></a>简述 HTTP1.0/1.1/2.0 的区别</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>HTTP 1.0 是在 1996 年引入的，从那时开始，它的普及率就达到了惊人的效果。</p>
<ul>
<li>HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。</li>
<li>HTTP 1.0 被设计用来使用短链接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。</li>
<li>HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li>
<li>HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li>
<li>HTTP 1.0 认为每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 1999 年，它做出了以下方面的变化</p>
<ul>
<li>HTTP 1.1 使用了摘要算法来进行身份验证</li>
<li>HTTP 1.1 默认使用长连接，长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li>
<li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</li>
<li>HTTP 1.1 支持断点续传，通过使用请求头中的 <code>Range</code> 来实现。</li>
<li>HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP 2.0 是 2015 年开发出来的标准，它主要做的改变如下</p>
<ul>
<li><code>头部压缩</code>，由于 HTTP 1.1 经常会出现 <strong>User-Agent、Cookie、Accept、Server、Range</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li>
<li><code>二进制格式</code>，HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，提升了解析效率</li>
<li><code>强化安全</code>，由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 HTTPS 上。</li>
<li><code>多路复用</code>，即每一个请求都是是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。</li>
</ul>
<p><img src="https://yanxuan.nosdn.127.net/b966a9273709064f4171f6ae6917472c.png" alt="img"></p>
<h2 id="请你说一下-HTTP-常见的请求头"><a href="#请你说一下-HTTP-常见的请求头" class="headerlink" title="请你说一下 HTTP 常见的请求头"></a>请你说一下 HTTP 常见的请求头</h2><p>这个问题比较开放，因为 HTTP 请求头有很多，这里只简单举出几个例子。</p>
<p>HTTP 标头会分为四种，分别是 <code>通用标头</code>、<code>实体标头</code>、<code>请求标头</code>、<code>响应标头</code>。分别介绍一下</p>
<h3 id="通用标头"><a href="#通用标头" class="headerlink" title="通用标头"></a>通用标头</h3><p>通用标头主要有三个，分别是 <code>Date</code>、<code>Cache-Control</code> 和 <code>Connection</code></p>
<p><strong>Date</strong></p>
<p>Date 是一个通用标头，它可以出现在请求标头和响应标头中，它的基本表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<p>表示的是格林威治标准时间，这个时间要比北京时间慢八个小时</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>Cache-Control</strong></p>
<p>Cache-Control 是一个通用标头，他可以出现在<code>请求标头</code>和<code>响应标头</code>中，Cache-Control 的种类比较多，虽然说这是一个通用标头，但是有一些特性是请求标头具有的，有一些是响应标头才有的。主要大类有 <code>可缓存性</code>、<code>阈值性</code>、 <code>重新验证并重新加载</code> 和<code>其他特性</code></p>
<p><strong>Connection</strong></p>
<p>Connection 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。Connection 有两种，一种是<code>持久性连接</code>，即一次事务完成后不关闭网络连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>另一种是<code>非持久性连接</code>，即一次事务完成后关闭网络连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>HTTP1.1 其他通用标头如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDWjX0AWOxGVEib9VQ246ib4fplMDVcFPSSia69fd1HHcj2BpWicXtnInkFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="实体标头"><a href="#实体标头" class="headerlink" title="实体标头"></a>实体标头</h3><p>实体标头是描述消息正文内容的 HTTP 标头。实体标头用于 HTTP 请求和响应中。头部<code>Content-Length</code>、 <code>Content-Language</code>、 <code>Content-Encoding</code> 是实体头。</p>
<ul>
<li><p>Content-Length 实体报头指示实体主体的大小，以字节为单位，发送到接收方。</p>
</li>
<li><p>Content-Language 实体报头描述了客户端或者服务端能够接受的语言。</p>
</li>
<li><p>Content-Encoding 这又是一个比较麻烦的属性，这个实体报头用来压缩媒体类型。Content-Encoding 指示对实体应用了何种编码。</p>
<p>常见的内容编码有这几种： <strong>gzip、compress、deflate、identity</strong> ，这个属性可以应用在请求报文和响应报文中</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate &#x2F;&#x2F;请求头</span><br><span class="line">Content-Encoding: gzip  &#x2F;&#x2F;响应头</span><br></pre></td></tr></table></figure>

<p>下面是一些实体标头字段</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDmOLlHibcn5pApnt9gteOZ3vZbJ8GTpaHLpAezeFNKaO735dQtCQYMIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="请求标头"><a href="#请求标头" class="headerlink" title="请求标头"></a>请求标头</h3><p><strong>Host</strong></p>
<p>Host 请求头指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的 TCP 端口号。如果没有给定端口号，会自动使用被请求服务的默认端口（比如请求一个 HTTP 的 URL 会自动使用 80 作为端口）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: developer.mozilla.org</span><br></pre></td></tr></table></figure>

<p>上面的 <code>Accpet</code>、 <code>Accept-Language</code>、<code>Accept-Encoding</code> 都是属于内容协商的请求标头。</p>
<p><strong>Referer</strong></p>
<p>HTTP Referer 属性是请求标头的一部分，当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;testpage.html</span><br></pre></td></tr></table></figure>

<p><strong>If-Modified-Since</strong></p>
<p>If-Modified-Since 通常会与 If-None-Match 搭配使用，If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 <code>Last-Modified</code> 来确定。</p>
<p>大白话说就是如果在 <code>Last-Modified</code> 之后更新了服务器资源，那么服务器会响应 200，如果在 <code>Last-Modified</code> 之后没有更新过资源，则返回 304。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT</span><br></pre></td></tr></table></figure>

<p><strong>If-None-Match</strong></p>
<p>If-None-Match HTTP 请求标头使请求成为条件请求。对于 GET 和 HEAD 方法，仅当服务器没有与给定资源匹配的 <code>ETag</code> 时，服务器才会以 200 状态发送回请求的资源。对于其他方法，仅当最终现有资源的<code>ETag</code>与列出的任何值都不匹配时，才会处理请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;c561c68d0ba92bbeb8b0fff2a9199f722e3a621a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Accept</strong></p>
<p>接受请求 HTTP 标头会通告客户端其能够理解的 MIME 类型</p>
<p><strong>Accept-Charset</strong></p>
<p>accept-charset 属性规定服务器处理表单数据所接受的字符集。</p>
<p>常用的字符集有：UTF-8 - Unicode 字符编码 ；ISO-8859-1 - 拉丁字母表的字符编码</p>
<p><strong>Accept-Language</strong></p>
<p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。</p>
<p>请求标头我们大概就介绍这几种，后面会有一篇文章详细深挖所有的响应头的，下面是一个响应头的汇总，基于 HTTP 1.1</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<h3 id="响应标头"><a href="#响应标头" class="headerlink" title="响应标头"></a>响应标头</h3><p><strong>Access-Control-Allow-Origin</strong></p>
<p>一个返回的 HTTP 标头可能会具有 Access-Control-Allow-Origin ，<code>Access-Control-Allow-Origin</code> 指定一个来源，它告诉浏览器允许该来源进行资源访问。</p>
<p><strong>Keep-Alive</strong></p>
<p>Keep-Alive 表示的是 Connection 非持续连接的存活时间，可以进行指定。</p>
<p><strong>Server</strong></p>
<p>服务器标头包含有关原始服务器用来处理请求的软件的信息。</p>
<p>应该避免使用过于冗长和详细的 Server 值，因为它们可能会泄露内部实施细节，这可能会使攻击者容易地发现并利用已知的安全漏洞。例如下面这种写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache&#x2F;2.4.1 (Unix)</span><br></pre></td></tr></table></figure>

<p><strong>Set-Cookie</strong></p>
<p>Set-Cookie 用于服务器向客户端发送 sessionID。</p>
<p><strong>Transfer-Encoding</strong></p>
<p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</p>
<p>HTTP /1.1 的传输编码方式仅对分块传输编码有效。</p>
<p><strong>X-Frame-Options</strong></p>
<p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。</p>
<p>首部字段 <code>X-Frame-Options</code> 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p>
<p>下面是一个响应头的汇总，基于 HTTP 1.1</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDR237JuRChQK38cm6AlHnEjdAzPXXv0JicLxxricgLxHPIsOBnpKR1W7w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="地址栏输入-URL-发生了什么"><a href="#地址栏输入-URL-发生了什么" class="headerlink" title="地址栏输入 URL 发生了什么"></a>地址栏输入 URL 发生了什么</h2><p>这道题也是一道经常会考的面试题。那么下面我们就来探讨一下从你输入 URL 后到响应，都经历了哪些过程。</p>
<ul>
<li>首先，你需要在浏览器中的 URL 地址上，输入你想访问的地址，如下</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDc8V067ha76EWPiaHveIaXxicTFRaGE63qmRrQyq0beXVFbdXicjyJDibWw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>你应该访问不到的，对不对~</p>
<ul>
<li>然后，浏览器会根据你输入的 URL 地址，去查找域名是否被本地 DNS 缓存，不同浏览器对 DNS 的设置不同，如果浏览器缓存了你想访问的 URL 地址，那就直接返回 ip。如果没有缓存你的 URL 地址，浏览器就会发起系统调用来查询本机 <code>hosts</code> 文件是否有配置 ip 地址，如果找到，直接返回。如果找不到，就向网络中发起一个 DNS 查询。</li>
</ul>
<blockquote>
<p>首先来看一下 DNS 是啥，互联网中识别主机的方式有两种，通过<code>主机名</code>和 <code>IP 地址</code>。我们人喜欢用名字的方式进行记忆，但是通信链路中的路由却喜欢定长、有层次结构的 IP 地址。所以就需要一种能够把主机名到 IP 地址的转换服务，这种服务就是由 DNS 提供的。DNS 的全称是 <code>Domain Name System</code> 域名系统。DNS 是一种由分层的 DNS 服务器实现的分布式数据库。DNS 运行在 UDP 上，使用 53 端口。</p>
<p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_483e5b5decf59f5cf3065a80f6da0d2b.png" alt="img"></p>
</blockquote>
<p>DNS 是一种分层数据库，它的主要层次结构如下</p>
<p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_090de1509b3f384c768aa22237cbe160.png" alt="img"></p>
<p>一般域名服务器的层次结构主要是以上三种，除此之外，还有另一类重要的 DNS 服务器，它是 <code>本地 DNS 服务器(local DNS server)</code>。严格来说，本地 DNS 服务器并不属于上述层次结构，但是本地 DNS 服务器又是至关重要的。每个 <code>ISP(Internet Service Provider)</code> 比如居民区的 ISP 或者一个机构的 ISP 都有一台本地 DNS 服务器。当主机和 ISP 进行连接时，该 ISP 会提供一台主机的 IP 地址，该主机会具有一台或多台其本地 DNS 服务器的 IP地址。通过访问网络连接，用户能够容易的确定 DNS 服务器的 IP地址。当主机发出 DNS 请求后，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次系统中。</p>
<p>首先，查询请求会先找到本地 DNS 服务器来查询是否包含 IP 地址，如果本地 DNS 无法查询到目标 IP 地址，就会向根域名服务器发起一个 DNS 查询。</p>
<blockquote>
<p>注意：DNS 涉及两种查询方式：一种是<code>递归查询(Recursive query)</code> ，一种是<code>迭代查询(Iteration query)</code>。《计算机网络：自顶向下方法》竟然没有给出递归查询和迭代查询的区别，找了一下网上的资料大概明白了下。</p>
<p>如果根域名服务器无法告知本地 DNS 服务器下一步需要访问哪个顶级域名服务器，就会使用递归查询；</p>
<p>如果根域名服务器能够告知 DNS 服务器下一步需要访问的顶级域名服务器，就会使用迭代查询。</p>
</blockquote>
<p>在由根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威 DNS 服务器后，由权威服务器告诉本地服务器目标 IP 地址，再有本地 DNS 服务器告诉用户需要访问的 IP 地址。</p>
<ul>
<li>第三步，浏览器需要和目标服务器建立 TCP 连接，需要经过三次握手的过程，具体的握手过程请参考上面的回答。</li>
<li>在建立连接后，浏览器会向目标服务器发起 <code>HTTP-GET</code> 请求，包括其中的 URL，HTTP 1.1 后默认使用长连接，只需要一次握手即可多次传输数据。</li>
<li>如果目标服务器只是一个简单的页面，就会直接返回。但是对于某些大型网站的站点，往往不会直接返回主机名所在的页面，而会直接重定向。返回的状态码就不是 200 ，而是 301,302 以 3 开头的重定向码，浏览器在获取了重定向响应后，在响应报文中 Location 项找到重定向地址，浏览器重新第一步访问即可。</li>
<li>然后浏览器重新发送请求，携带新的 URL，返回状态码 200 OK，表示服务器可以响应请求，返回报文。</li>
</ul>
<h2 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h2><p>我们上面描述了一下 HTTP 的工作原理，下面来讲述一下 HTTPS 的工作原理。因为我们知道 HTTPS 不是一种新出现的协议，而是</p>
<p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_1b475c08295aac95a5d9f581fe9b48db.png" alt="img"></p>
<p>所以，我们探讨 HTTPS 的握手过程，其实就是 SSL/TLS 的握手过程。</p>
<p>TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 TLS 握手期间，Internet 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。</p>
<p>每当用户通过 HTTPS 导航到具体的网站并发送请求时，就会进行 TLS 握手。除此之外，每当其他任何通信使用HTTPS（包括 API 调用和在 HTTPS 上查询 DNS）时，也会发生 TLS 握手。</p>
<p>TLS 具体的握手过程会根据所使用的<code>密钥交换算法的类型</code>和双方支持的<code>密码套件</code>而不同。我们以<code>RSA 非对称加密</code>来讨论这个过程。整个 TLS 通信流程图如下</p>
<p><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_4d1f7d77dd092e318e7cdd567bfbd9ee.png" alt="img"></p>
<ul>
<li>在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程</li>
<li>ClientHello：客户端通过向服务器发送 <code>hello</code> 消息来发起握手过程。这个消息中会夹带着客户端支持的 <code>TLS 版本号(TLS1.0 、TLS1.2、TLS1.3)</code> 、客户端支持的密码套件、以及一串 <code>客户端随机数</code>。</li>
<li>ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。</li>
<li>认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 <code>Certificate</code> 报文，报文中包含公开密钥证书。最后服务器发送 <code>ServerHelloDone</code> 作为 <code>hello</code> 请求的响应。第一部分握手阶段结束。</li>
<li><code>加密阶段</code>：在第一个阶段握手完成后，客户端会发送 <code>ClientKeyExchange</code> 作为响应，这个响应中包含了一种称为 <code>The premaster secret</code> 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 <code>ChangeCipherSpec</code>，告诉服务端使用私钥解密这个 <code>premaster secret</code> 的字符串，然后客户端发送 <code>Finished</code> 告诉服务端自己发送完成了。</li>
</ul>
<blockquote>
<p>Session key 其实就是用公钥证书加密的公钥。</p>
</blockquote>
<ul>
<li><code>实现了安全的非对称加密</code>：然后，服务器再发送 <code>ChangeCipherSpec</code> 和 <code>Finished</code> 告诉客户端解密完成，至此实现了 RSA 的非对称加密。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/16/https/" itemprop="url">
                  HTTP 与 HTTPS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-16T20:50:33+08:00">
                2020-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>http 对称加密</code><br><code>https</code> = <code>http</code> + <code>SSL/TLS 非对称加密</code></p>
<ul>
<li>非对称加密算法：RSA，DSA/DSS </li>
<li>对称加密算法：AES，RC4，3DES </li>
<li>HASH算法：MD5，SHA1，SHA256</li>
</ul>
<p>https 仅是在双方交换证书时使用非对称加密，进行实际数据交换时，依然使用的是对称加密。</p>
<p>SSL 解决的是服务器端公钥在传输过程中可能被中间人拦截的问题。</p>
<p>服务端中保存一份私钥。并通过此私钥产生一个公钥，这两者之间的关系，私钥加密的数据可以通过公钥解密，通过公钥加密的数据通过私钥解密。</p>
<p>当浏览器向服务器发起请求，浏览器将自己支持的一套加密规则发送给网站。</p>
<p>服务端通过CA的私钥加密服务端的公钥（通常包含 服务端的公钥 + 盐）。以及明文写入的网站名称等签名信息，将此密文发给浏览器。</p>
<p>浏览器端通过CA的公钥解密密文（即判断服务端证书的合法性，通过与操作系统中安装的根证书进行对比，如果不合法，会给出警告，报告此次通信是不安全的），得到服务端公钥。</p>
<p>即使中间人利用CA的公钥解密了密文，但无法进行修改，因为没有服务器端的私钥。</p>
<p>浏览器产生一个随机数，用服务器的公钥加密随机数，传输到服务器端。</p>
<p>服务器端解密出此随机数。</p>
<p>随后浏览器与服务器通过此随机数进行加密数据通信。</p>
<hr>
<p> 证书：直观的看，证书包括以下这些内容：</p>
<ol>
<li>证书序列号</li>
<li>证书过期时间</li>
<li>站点组织名</li>
<li>站点DNS主机名</li>
<li>站点公钥</li>
<li>证书颁发者名</li>
<li>证书签名</li>
</ol>
<hr>
<p>假设你想要成为一个受信任的网站或机构，只需要找你的上级机构去颁发证书给你，颁发时你将自己的公钥，host等信息发送到颁发机构，该机构会将自己的证书附上你的信息，并用自己的私钥签名，做成一张新的证书发给你；<br>而这个上级机构他的证书又是同样的方法由CA颁发的。</p>
<p>那么，其他人怎么确认你的证书是合法的呢?</p>
<blockquote>
<p>首先你的证书会在https握手过程中被传递到浏览器，浏览器从你的证书中找到了颁发者，从颁发者的证书（如果你电脑上有的话）又找到了CA的证书（CA证书会在操作系统安装时就安装好，所以每个人电脑上都有根证书），使用CA证书中带的公钥来对颁发者证书做验签，一旦匹配，说明你电脑上的颁发者证书不是伪造的，同理，再用颁发者证书中的公钥去验证你的证书，以此证明你的证书不是伪造的。这样整个链状的验证，从而确保你的证书一定是直接或间接从CA签发的，这样浏览器地址栏会显示一个绿色的盾牌，表示你的网站能通过证书验证.</p>
</blockquote>
<blockquote>
<p>详细<br>假设这是一个浏览器的HTTPS请求</p>
</blockquote>
<p> 一：首先浏览器通过URL网址去请求服务端，服务端接收到请求后，就会给浏览器发送一个自己的CA数字证书</p>
<p> 二：浏览器接收到证书以后，就要开始进行验证工作了。首先从证书中得知证书的颁发机构，然后从浏览器系统中去寻找此颁发机构的根证书。上面我们也看到，世界上权威CA机构的根证书都是预先嵌入到浏览器中的，如果在浏览器系中没有找到对应的根证书，就代表此机构不是受信任的，那么就会警告无法确认证书的真假，比如以前打开12360网站就会提示，现在不会了</p>
<p> 如果我们找到了证书颁发机构的根证书，那么就从根证书中取得那个根公钥，用根公钥去解密此证书的数字签名，成功解密的话就得到证书的指纹和指纹算法，指纹是证书内容通过指纹算法计算得到的一个hash值，这里我们称之为h1，h1代表证书的原始内容；然后用指纹算法对当前接收到的证书内容再进行一次hash计算得到另一个值h2，h2则代表当前证书的内容，如果此时h1和h2是相等的，就代表证书没有被修改过。如果证书被篡改过，h2和h1是不可能相同的，因为hash值具有唯一性，不同内容通过hash计算得到的值是不可能相同的</p>
<p> 有人说假如证书上的指纹是不法分子伪造的，伪造是没有用的，因为你伪造的指纹不可能用CA机构的根私钥去加密（根私钥是CA机构绝对保密的），伪造者只能拿自己的秘钥去加密这个伪造的指纹，但当我们拿机构的根公钥去解密伪造指纹的时候是不可能成功的（加密内容只能由一对公钥私钥解密）</p>
<p> 在证书没有被修改过的基础上，再检查证书上的使用者的URL（比如csdn.net）和我们请求的URL是否相等，如果相等，那么就可以证明当前浏览器链接的网址也是正确的，而不是一些钓鱼网之类的</p>
<p> 但如果浏览器的连接被某个中间人截取了，中间人也可以发一个由权威的CA机构颁发的证书给浏览器，然后也可以通过证书没有被篡改的验证，但是在证书没有被篡改的前提下，通过对比证书上的URL和我们请求的URL是否相同，我们还是可以判断当前证书是不是服务器发的证书。可以这么理解，因为URL具有唯一性，所以中间人的证书的上的URL和我们的证书的URL是不可能相同的，如果中间人修改了自己证书上的URL，那么就通过不了证书没有被篡改的验证，所以中间人的证书也是欺骗不了我们的</p>
<p> 到这里我们认证了三点信息：</p>
<p> 1.证书是否为受信任的权威机构颁发的</p>
<p> 2.证书是否被篡改</p>
<p> 3.证书是否为服务器发过来的，而不是第三方发的</p>
<p> 三：基于上面的三点信息认证都没有问题的情况下，下一步我们有一个重要的任务就是，如何将一个对称加密算法的秘钥安全地发给服务器</p>
<p> 首先随机生成一个字符串S作为我们的秘钥，然后通过证书公钥加密成密文，将密文发送给服务器。因为此密文是用公钥加密的，这是一个非对称加密，我们知道，这个密文只有私钥的持有者才能进行解密，在这里私钥的持有者当然是服务器了，所以说任何第三方截取到密文也是没用的，因为没有对应的私钥无法解密得到我们的密文</p>
<p> 还有一个关键步骤，发送密文的时候也会对消息内容进行签名操作。签名上面讲解过，就是对密文内容进行hash计算得到的hash值再通过公钥或私钥加密得到的一段数字串，这个签名和消息内容一起发送出去。接收方收到消息以后，通过私钥或公钥解析出密文和签名的hash值，同时也会对接收的消息内容进行同样的hash计算得到另一个hash值，比对两个hash值是否相同来判断消息有没有被篡改过</p>
<p> 四：通过了上面的步骤以后，此时客户端和服务端都持有了对称加密算法的同一个秘钥，然后兄弟俩就可以愉快地安全通信了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/UDP%E4%B8%AD%E7%9A%84connect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/15/UDP%E4%B8%AD%E7%9A%84connect/" itemprop="url">
                  UDP中的 connect
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-15T21:48:36+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>标准的udp客户端开了套接口后，一般使用<code>sendto</code>和<code>recvfrom</code>函数来发数据，但同样可以使用<code>send</code>函数进行发送。</p>
<p><strong>方法一</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket-----&gt;sendto()或recvfrom()</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket-----&gt;connect()-----&gt;send()或recv()</span><br></pre></td></tr></table></figure>

<p>在<strong>UDP</strong>中也是可以使用<strong>connect</strong>的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> tolen)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span>  s, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sockaddr *from,  <span class="keyword">socklen_t</span> *fromlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sendto</code>和<code>recvfrom</code>在收发时需要指定地址，而<code>send</code>和<code>recv</code>则没有，那么他们的地址是在那里指定的呢，答案就在于<code>connect</code>!!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_taddrlen);</span><br></pre></td></tr></table></figure>

<p>在UDP编程中，如果你只往一个地址发送，那么你可以使用<code>send</code>和<code>recv</code>，在使用它们之前用<code>connect</code>把它们的目的地址指定一下就可以了。<code>connect</code>函数在<code>UDP</code>中就是这个作用，用它来检测<code>UDP</code>端口的是否开放是没有用的。下面是<code>ntpclient</code>中的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa_dest</span>;</span></span><br><span class="line">bzero((<span class="keyword">char</span> *)sa_dest, <span class="keyword">sizeof</span>(*sa_dest));</span><br><span class="line">sa_dest-&gt;sin_family = AF_INET;</span><br><span class="line"><span class="keyword">if</span> (StuffNetAddr(&amp;(sa_dest-&gt;sin_addr), host))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">sa_dest-&gt;sin_port = htons(port);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(usd, (struct sockaddr *)&amp;sa_dest, <span class="keyword">sizeof</span>(sa_dest)) == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"connect"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>[unix网络编程8.11]除非套接口已连接，否则异步错误是不会返回到UDP套接口的，我们确实可以给UDP套接口调用connect，然而这样做的结果却与<strong>TCP连接大相径庭</strong>：没有三路握手过程。相反内核只是检查是否存在<strong>立即可知的错误</strong>(例如一个显然不可达的目的地)，记录对端的IP地址和端口号（取自传递给connect的套接口地址结构），然后立即返回到调用进程。</p>
</blockquote>
<p>对于<strong>已连接UDP套接口(对缺省的套接字调用connect)</strong>，与缺省的<strong>未连接套接口</strong>相比，发生了三个变化：</p>
<ol>
<li>我们再也<strong>不能给输出操作指定目的IP地址和端口号</strong>，也就是说我们不使用sendto，而改用write或send，写到已连接UDP套接口上的任何内容都自动发送到由connect指定的协议地址（例如IP地址和端口号）</li>
<li>我们不必使用<code>recvfrom</code>以获悉数据报的发送者，<strong>而改用read，recv或recvmsg</strong>，在一个已连接UDP套接口上由内核为输入操作返回的数据 报仅仅是那些来自connect所指定协议地址的数据报。目的地为这个已连接UDP套接口的本地协议地址，发源地却不是该套接口早先connect到的协 议地址的数据报，不会投递到该套接口。这样就限制了一个已连接UDP套接口而且仅能与一个对端交换数据报。</li>
<li>由已连接的UDP套接口引发的异步错误会返回给他们所在的进程。而未连接UDP套接字不接收任何错误。</li>
</ol>
<p>相反我们说过未连接UDP套接口不接收任何异步错误，给一个UDP套接口多次调用connect可以为下列2个目的之一：</p>
<ol>
<li>指定新的IP地址和端口号；</li>
<li>断开套接口</li>
</ol>
<p>第一个目的（即给一个已连接UDP套接口指定新的对端）不同于TCP套接口中connect的使用:对于TCP套接口，connect只能调用一次。</p>
<p>为了断开一个已connect的UDP套接口连接，我们再次调用connect时把套接口地址结构的地址簇成员（sin_family）设置为<code>AF_UNSPEC</code>。<br>这么做可能返回一个<code>EAFNOSUPPORT</code>错误，不过没有关系。<br>使得套接口断开连接的是在已连接UDP套接口上调用connect的进程。</p>
<p><strong>调用 connect 有如下的一些好处</strong>：</p>
<ol>
<li>选定了对端，内核只会将帮定对象的对端发来的数据报传给套接口，因此在一定环境下可以提升安全性；</li>
<li><strong>会返回异步错误</strong>，如果对端没启动，<strong>默认情况下发送的包对应的ICMP回射包不会给调用进程</strong>，如果用了connect，<strong>嘿嘿</strong></li>
<li>发送两个包间不会发生断开再连接，提升了效率。</li>
</ol>
<p>做个实验测试下吧</p>
<p>先弄个UDP回射服务器，把所有收到的数据报回射回去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>                sockListener, nMsgLen;</span><br><span class="line">    <span class="keyword">char</span>               szBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrListener</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>          addrLen;</span><br><span class="line">    addrLen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    bzero(&amp;addrListener, <span class="keyword">sizeof</span>(addrListener));</span><br><span class="line">    addrListener.sin_family = AF_INET;</span><br><span class="line">    addrListener.sin_port   = htons(<span class="number">8000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((sockListener = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"error in getting a socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (bind(sockListener, (struct sockaddr *)&amp;addrListener,</span><br><span class="line">             <span class="keyword">sizeof</span>(addrListener)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind a listener for a socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrClient</span>;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"start listenning"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        nMsgLen = recvfrom(sockListener, szBuf, <span class="number">1024</span>, <span class="number">0</span>,</span><br><span class="line">                           (struct sockaddr *)&amp;addrClient, &amp;addrLen);</span><br><span class="line">        <span class="keyword">if</span> (nMsgLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            szBuf[nMsgLen] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"send back:"</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            sendto(sockListener, szBuf, nMsgLen, <span class="number">0</span>,</span><br><span class="line">                   (struct sockaddr *)&amp;addrClient, addrLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写个客户端，绑定个端口，再连接服务器端。随时接受键盘输入并发送到服务器端，随时接受端口到来的数据并打印。如果没有连接 ，发送到此端口的数据会被接受，但是调用connect后会怎样呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>                sockClient, nMsgLen, nReady;</span><br><span class="line">    <span class="keyword">char</span>               szRecv[<span class="number">1024</span>], szSend[<span class="number">1024</span>], szMsg[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrServer</span>, <span class="title">addrClient</span>, <span class="title">addrLocal</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>          addrLen;</span><br><span class="line">    fd_set             setHold, setTest;</span><br><span class="line"> </span><br><span class="line">    sockClient = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    addrLen    = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    bzero(&amp;addrServer, <span class="keyword">sizeof</span>(addrServer));</span><br><span class="line">    addrServer.sin_family      = AF_INET;</span><br><span class="line">    addrServer.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    addrServer.sin_port        = htons(<span class="number">8000</span>);</span><br><span class="line"> </span><br><span class="line">    addrLocal.sin_family      = AF_INET;  <span class="comment">// bind to a local port</span></span><br><span class="line">    addrLocal.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addrLocal.sin_port        = htons(<span class="number">9000</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockClient, (struct sockaddr *)&amp;addrLocal, <span class="keyword">sizeof</span>(addrLocal)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"error in binding"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockClient, (struct sockaddr *)&amp;addrServer,</span><br><span class="line">                <span class="keyword">sizeof</span>(addrServer)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"error in connecting"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    FD_ZERO(&amp;setHold);</span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;setHold);</span><br><span class="line">    FD_SET(sockClient, &amp;setHold);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"you can type in sentences any time"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        setTest = setHold;</span><br><span class="line">        nReady  = select(sockClient + <span class="number">1</span>, &amp;setTest, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(<span class="number">0</span>, &amp;setTest)) &#123;</span><br><span class="line">            nMsgLen = <span class="built_in">read</span>(<span class="number">0</span>, szMsg, <span class="number">1024</span>);</span><br><span class="line">            <span class="built_in">write</span>(sockClient, szMsg, nMsgLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockClient, &amp;setTest)) &#123;</span><br><span class="line">            nMsgLen         = <span class="built_in">read</span>(sockClient, szRecv, <span class="number">1024</span>);</span><br><span class="line">            szRecv[nMsgLen] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"read:"</span> &lt;&lt; szRecv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来个“第三者”，向第二个的端口发数据报。看她会不会成为忠贞的感情守护人:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">socklen_t</span>          addrLen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrServer</span>;</span></span><br><span class="line">    <span class="keyword">char</span>               szMsg[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span>                sockClient;</span><br><span class="line"> </span><br><span class="line">    addrServer.sin_family      = AF_INET;</span><br><span class="line">    addrServer.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    addrServer.sin_port        = htons(<span class="number">9000</span>);</span><br><span class="line"> </span><br><span class="line">    sockClient = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">snprintf</span>(szMsg, <span class="keyword">sizeof</span>(szMsg), <span class="string">"this is %d"</span>, id++);</span><br><span class="line">        sendto(sockClient, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;addrServer, <span class="keyword">sizeof</span>(addrServer));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现运行第一个程序，再运行第三个程序，然后运行第二个程序。</p>
<p>服务器端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">callback server begin to listen</span><br><span class="line">send back:xinheblue likes playing</span><br><span class="line"> </span><br><span class="line">send back:and listenning to music</span><br></pre></td></tr></table></figure>

<p>第二个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">you can type in sentences any time</span><br><span class="line">xinheblue likes playing</span><br><span class="line">read:xinheblue likes playing</span><br><span class="line"> </span><br><span class="line">and listenning to music</span><br><span class="line">read:and listenning to music</span><br></pre></td></tr></table></figure>

<p>实现结果证明，第二个程序调用connect后，不接收第三个程序发来的数据包。</p>
<h2 id="udp客户端-用不用-bind-的区别"><a href="#udp客户端-用不用-bind-的区别" class="headerlink" title="udp客户端 用不用 bind 的区别"></a>udp客户端 用不用 bind 的区别</h2><p>无连接的socket的客户端和服务端以及面向连接socket的服务端通过调用bind函数来配置本地信息。使用bind函数时，通过将my_addr.sin_port置为0，函数会自动为你选择一个未占用的端口来使用。<br>Bind()函数在成功被调用时返回0；出现错误时返回”-1”并将errno置为相应的错误号。需要注意的是，在调用bind函数时一般不要将端口号置为小于1024的值，因为1到1024是保留端口号，你可以选择大于1024中的任何一个没有被占用的端口号。</p>
<p>有连接的socket客户端通过调用Connect函数在socket数据结构中保存本地和远端信息，无须调用bind()，因为这种情况下只需知道目的机器的IP地址，而客户通过哪个端口与服务器建立连接并不需要关心，socket执行体为你的程序自动选择一个未被占用的端口，并通知你的程序数据什么时候打开端口。（当然也有特殊情况，linux系统中rlogin命令应当调用bind函数绑定一个未用的保留端口号，还有当客户端需要用指定的网络设备接口和端口号进行通信等等）<br>总之：</p>
<ol>
<li>需要在建连前就知道端口的话，需要 bind</li>
<li>需要通过指定的端口来通讯的话，需要 bind</li>
</ol>
<p>具体到上面那两个程序，本来用的是TCP，客户端就不用绑定端口了，绑定之后只能运行一个client的程序属于自己人为设定的障碍，而从服务器那边得到的客户机连接端口号（是系统自动分配的）与这边客户机绑定的端口号根本是不相关的，所以客户端绑定也就失去了意义。</p>
<p>首先，服务器和客户端都可以bind，bind并不是服务器的专利。<br>客户端进程bind端口： 由进程选择一个端口去连服务器，（如果默认情况下，调用bind函数时，内核指定的端口是同一个，那么调用多个调用了bind（）的client程序，会出现端口被占用的错误）注意这里的端口是客户端的端口。如果不分配就表示交给内核去选择一个可用端口。<br>客户端进程bind IP地址：相当于为发送出去的IP数据报分配了源IP地址，但交给进程分配IP地址的时候（就是这样写明了bind IP地址的时候）这个IP地址必须是主机的一个接口，不能分配一个不存在的IP。如果不分配就表示由内核根据所用的输出接口来选择源IP地址。</p>
<p>一般情况下客户端是不用调用bind函数的，一切都交给内核搞定！</p>
<p>服务端进程bind端口：基本是必须要做的事情，比如一个服务器启动时（比如freebsd），它会一个一个的捆绑众所周知的端口来提供服务，同样，如果bind了一个端口就表示我这个服务器会在这个端口提供一些“特殊服务”。<br>服务端进程bind IP地址：目的是限制了服务端进程创建的socket只接受那些目的地为此IP地址的客户链接，一般一个服务器程序里都有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// 只是针对IP4，IP6代码不太一样</span></span><br></pre></td></tr></table></figure>

<p>这样一句话，意思就是：我不指定客户端的IP，随便连，来者不拒！</p>
<p>总之只要你bind时候没有指定哪一项（置为0），内核会帮你选择。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/14/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/14/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url">
                  Unix网络编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-14T20:20:17+08:00">
                2020-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="传输层部分知识点"><a href="#传输层部分知识点" class="headerlink" title="传输层部分知识点"></a>传输层部分知识点</h2><h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><ul>
<li>MSL: maximum segment lifetime</li>
</ul>
<p>任何TCP的实现都需要为MSL选择一个合适的值, RFC的建议值是2分钟。分组可能出现迷途，若迷途分组在MSL中找到路， 造成重复，TCP必须修复</p>
<p><code>TIME_WAIT</code>存在的理由:</p>
<ol>
<li><p><strong>可靠的实现全双工的连接和终止</strong><br> 考虑最终<code>ACK</code>丢失的情况,</p>
</li>
<li><p><strong>允许老的重复分组在网络中消逝</strong></p>
<p>TCP的化生身现象, 因为<code>TIME_WAIT</code>的时间是2MSL, 故<code>TIME_WAIT</code>可以确保先前化身(incarnation)的老重复分组都已经在网络中消失了</p>
<blockquote>
<p>不过存在一个例外: 如果到达的SYN的序列号大于前一化身的结束序列号,源自Berkely的实现应该给当前<code>**TIME_WAIT**</code>状态的连接启动新的化身</p>
</blockquote>
</li>
</ol>
<h3 id="SCTP"><a href="#SCTP" class="headerlink" title="SCTP"></a>SCTP</h3><p><strong>连接</strong>: 类似TCP, 但是是四路握手, 主要差别在于作为SCTP整体的一部分的cookie的生成<br><strong>终止</strong>: 不允许”半关闭”</p>
<p><img src="https://ae02.alicdn.com/kf/H73231a5d00af414a8230ba256ed8ed9d1.png" alt="img"></p>
<p>连接和终止</p>
<h3 id="函数细节补充"><a href="#函数细节补充" class="headerlink" title="函数细节补充"></a>函数细节补充</h3><ul>
<li><p><code>inet_pton</code> and <code>inet_ntop</code></p>
<p> inet_addr已经被废弃了, inet_aton其实也不太好, 新的代码应该要使用<code>inet_pton</code> and <code>inet_ntop</code>, 例如如下例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sockaddr_in <span class="title">makeAddr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *addr, <span class="keyword">uint16_t</span> port)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ret</span>&#123;</span>&#125;;</span><br><span class="line">inet_pton(AF_INET, addr, &amp;ret.sin_addr.s_addr);</span><br><span class="line">  	<span class="comment">// ret.sin_addr.s_addr = inet_addr(addr); 例如用上面哪行代码代替此行</span></span><br><span class="line">  	ret.sin_family = AF_INET;</span><br><span class="line">  	ret.sin_port = htons(port);</span><br><span class="line">  	bzero(&amp;ret.sin_zero, <span class="number">8</span>)</span><br><span class="line">  	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>listen</code>的作用</p>
<p>  刚由<code>socket</code>创建的套接字, 系统默认其为主动套接字, <code>listen</code>的作用是把一个未连接的主动套接字转换为被动套接字. 第二个参数是内核为相应的socket排队的最大排队数 (incomplete connection queue: 处于<code>SYN_RCVD</code>状态)<br>     在linux 中，半连接队列的长度是由 /proc/sys/net/core/somaxconn（默认值 128） 与 backlog  tcp_max_syn_backlog 之间的最小值决定的。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/core/somaxconn 			//128</span><br></pre></td></tr></table></figure>




<h3 id="并发服务器的一个细节"><a href="#并发服务器的一个细节" class="headerlink" title="并发服务器的一个细节"></a>并发服务器的一个细节</h3><p>考虑如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"></span><br><span class="line">  listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span> = <span class="title">makeAddr</span>();</span></span><br><span class="line">  bind(listenfd, (sockaddr *)addr, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">listen</span>(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line"></span><br><span class="line">	 <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">	 connfd = accept(listenfd, (sockaddr_in) &amp;clientAddr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">if</span>(pid = fork()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">close</span>(listenfd);</span><br><span class="line">		 <span class="comment">// do something here</span></span><br><span class="line">		 <span class="built_in">close</span>(connfd);</span><br><span class="line">		 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(connfd); <span class="comment">//注意这里</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们知道, TCP套接口字调用close会导致发送一个FIN, 然后会连接终止, 为什么这里不会呢?</strong></p>
<p>  事实上, 每个文件或socket都会有一个引用计数(引用计数在文件表项中维护), fork的时候会让计数*2, 而close让计数-1, 所以不会出现问题, 真正socket的清理和资源的释放过程要等计数为0的时候才会发生</p>
<p>  注意, 如果一直fork了也不close, 那么会耗尽所有可用的文件描述符, 导致连接一直打开着</p>
<p>  如果我们确实想要某个TCP连接上发送一个FIN, 那么我们可以改用shutdown函数.</p>
<h3 id="处理被中断的系统调用"><a href="#处理被中断的系统调用" class="headerlink" title="处理被中断的系统调用"></a>处理被中断的系统调用</h3><p>  如<code>accept</code>, 是一个慢系统调用, 多数网络支持函数都属于这个类型. 当阻塞于慢系统调用的一个进程捕获某个信号且进入相应的处理函数的时候, 该系统调用可能返回一个<code>EINTR</code>错误.(有的内核自动重启某些被中断的系统调用), <strong>不过为了便于移植</strong>, 我们必须对<code>EINTR</code>有所准备, 一个处理办法就是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) </span><br><span class="line">&#123;</span><br><span class="line">    connfd = accept(listenfd, (sockaddr_in) &amp;clientAddr, &amp;addrlen);</span><br><span class="line">	 <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>) </span><br><span class="line">     &#123;</span><br><span class="line">	 	<span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">	 	<span class="keyword">else</span> </span><br><span class="line">        	perror(<span class="string">"accept"</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 有一个函数我们不能这样处理, 就是<code>connect</code>, 如果他出了<code>EINTR</code>, 再次调用会立即返回一个错误, 我们必须用<code>select</code>函数来等待连接完成</p>
<h3 id="处理accept返回前连接终止"><a href="#处理accept返回前连接终止" class="headerlink" title="处理accept返回前连接终止"></a>处理accept返回前连接终止</h3><p>如下图的情况的时候</p>
<p><img src="https://ae02.alicdn.com/kf/H1309cb050678454d981f9f2eab34dc55W.png" alt="img"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  所有客户端和服务器都从调用socket开始, 客户端connect, 服务端bind, listen和accept, 大多数TCP都是并发的, 而大多数UDP却是迭代的</p>
<h2 id="IO复用-–-select-和-poll"><a href="#IO复用-–-select-和-poll" class="headerlink" title="IO复用 – select 和 poll"></a>IO复用 – select 和 poll</h2><ul>
<li><p>当用户处理多个 描述符, 必须使用IO复用</p>
</li>
<li><p>如果一个TCP服务器, 既要处理监听的套接字, 又要处理连接的套接字, 就要使用IO复用</p>
</li>
<li><p>如果又要TCP, 又要UDP, 就要IO复用</p>
</li>
<li><p>如果一个服务器要处理多个服务器和多个协议, 通常要IO复用(例如inetd守护进程)</p>
</li>
</ul>
<p>IO复用并非只局限于网络编程, 许多重要的应用也要采用这个技术</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>在了解IO复用之前需要先回顾unix的5种IO模型: 阻塞式, 非阻塞式, 复用, 信号驱动IO, 异步IO</p>
<p>其中</p>
<p><strong>非阻塞IO</strong></p>
<blockquote>
<p>【UNIX网络编程6.2】进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。</p>
</blockquote>
<p><strong>信号驱动式IO</strong></p>
<blockquote>
<p>我们也可以使用信号，让内核在描述符就绪时发送SIGIO信号通知我们。</p>
<p>这种模型的优势在于等待数据报到达期间进程不会被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。</p>
</blockquote>
<p><strong>异步I/O</strong></p>
<blockquote>
<p>异步IO是由内核通知为我们IO操作何时完成。信号驱动IO是内核通知我们何时可以启动一个IO操作</p>
<p>无论是 <strong><em>select</em></strong>  <strong><em>poll</em></strong> <strong><em>epoll</em></strong> 都是同步IO操作</p>
<p>只有 windows <strong><em>IOCP</em></strong> 真正实现了异步IO操作</p>
</blockquote>
<p>POSIX对于同步IO与异步IO的定义：</p>
<ul>
<li>同步IO ： 导致请求被进程被阻塞，直到IO操作完成</li>
<li>异步IO :    不导致请求进程阻塞  </li>
</ul>
<p>5种模型的比较</p>
<p><img src="https://ae01.alicdn.com/kf/H3623b34425e7466a98f0cbec081f6fa4v.png" alt="img"></p>
<h3 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h3><p>select系统调用的的用途是：在一段指定的时间内，监听用户感兴趣的文件描述符上可读、可写和异常等事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 一个 select demo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set rd_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock_server = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">4999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"192.168.101.165"</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    bind(sock_server, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="built_in">listen</span>(sock_server, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[FD_SETSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">    <span class="keyword">int</span> nSock = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">array</span>[nSock++] = sock_server;</span><br><span class="line">    <span class="keyword">int</span> maxfd = sock_server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rd_set);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; maxfd)</span><br><span class="line">            &#123;</span><br><span class="line">                maxfd = <span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            FD_SET(<span class="built_in">array</span>[i], &amp;rd_set);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server Listening.....\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nums = select(maxfd + <span class="number">1</span>, &amp;rd_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Readable Fd Nums:%d\n"</span>, nums);</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"error on select"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sock_server, &amp;rd_set))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_cli</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(addr_cli);</span><br><span class="line">            <span class="keyword">int</span> nfd = accept(sock_server, (struct sockaddr *)&amp;addr_cli, &amp;len);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">array</span>[nSock++] = nfd;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"New Fd Come:%d\n"</span>,nfd);</span><br><span class="line">            <span class="keyword">if</span> (--nums &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(<span class="built_in">array</span>[i], &amp;rd_set))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nread;</span><br><span class="line">                ioctl(<span class="built_in">array</span>[i], FIONREAD, &amp;nread);</span><br><span class="line">                <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close</span>(<span class="built_in">array</span>[i]);</span><br><span class="line">                    <span class="built_in">array</span>[i] = <span class="built_in">array</span>[--nSock];</span><br><span class="line">                    <span class="built_in">array</span>[nSock]=<span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Fd %d Closed\n"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">read</span>(<span class="built_in">array</span>[i], &amp;buf, nread);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Recv From Fd %d:%s\n"</span>, <span class="built_in">array</span>[i], buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>注</strong></p>
<blockquote>
<p>close() 会直接发送FIN,并不在接收对方的任何报文，如果有收到报文会回复 RST<br>shutdown(sockfd, SHUT_WR),也就是只关闭了写的时候，会发送FIN报文，通知对端（关闭了写，其实没有明确flag表明是写）。对端的协议栈也会直接回复对FIN的ACK的，同时对端的socket状态会在协议栈发送了ack后变成CLOSE_WAIT。但是对端可以继续发送报文，然后本端也可以继续接收报文.</p>
</blockquote>
<blockquote>
<p>shutdown(sockfd, SHUT_RD),就是只关闭了读的时候，是不会发送任何表明关闭了读的协议报文的。同时对端还可以发送报文，本端也会回复ack，但是本端在用系统调用recv是收不到报文的，确切的说是：先以SHUT_RD调用了shutdown，再后面recv的时候是直接返回ret=0的，不管是阻塞还是非阻塞.</p>
</blockquote>
<blockquote>
<p>shutdown(sockfd, SHUT_RDWR),也就是关闭了读写的时候，会发送FIN报文，通知对端（关闭了读写，没有明确flag表明是读写）。对端的协议栈也会直接回复对FIN的ACK的，同时对端的socket状态会在协议栈发送了ack后变成CLOSE_WAIT。但是如果对端继续发送报文，那么主动关闭的一方会直接回RST的。</p>
</blockquote>
<blockquote>
<p>close关闭其实是减少计数，假如有dup过，那么并不会完全关闭套接字。<br>shutdown会直接根据参数对socket执行操作，而不管是不是dup过。</p>
</blockquote>
<h4 id="pselect函数"><a href="#pselect函数" class="headerlink" title="pselect函数"></a>pselect函数</h4><p>POSIX发明的, 有许多的unix变种支持，暂不详细讨论</p>
<ul>
<li>用timespec结构而不是timeval</li>
<li>增加一个指向信号的掩码的指针, 该参数允许程先序禁止递交某些信号, 再测试它们(这些信号)的handler设置的全局变量, 然后调用<code>pselect</code> (也就是暂时更换’信号掩码’, 例如解除某个信号的阻塞)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set* readset,fd_set* writeset, fd_set* exceptset, <span class="keyword">const</span> struct timespec* timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* sigmask)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h3><p>poll和select类似, 只不过在处理流函数的时候能够提供额外的信息。</p>
<table>
<thead>
<tr>
<th>常值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>POLLIN</td>
<td>普通或者优先级数据可读</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td>普通数据可读</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td>优先级带数据可读</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>高优先级数据可读</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>普通数据可写</td>
</tr>
<tr>
<td>POLLWRNORM</td>
<td>普通数据可写</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td>优先级带数据可写</td>
</tr>
<tr>
<td>POLLERR</td>
<td>发生错误</td>
</tr>
<tr>
<td>POLLHUP</td>
<td>发生挂起</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>描述符不是一个打开的文件</td>
</tr>
</tbody></table>
<p>就TCP和UDP套接字而言，以下条件引起poll返回特定的revent,但不幸的是，POSIX在poll的定义中留了许多空洞。</p>
<ul>
<li>所有正规TCP数据和所有UDP数据被认为普通数据</li>
<li>当TCP连接读半部关闭，譬如收到来自对端的FIN，也被认为是普通数据，随后的读操作将返回0.</li>
<li>TCP的连接存在错误既可以认为是普通数据，也可以认为是错误(<strong>POLLERR</strong>),无论哪种情况随后的读操作将返回-1，并把<strong>errno</strong>设置成合适的值。这可用于处理诸如接收到<strong>RST</strong>或发生超时等条件</li>
<li>在监听套接字上有新的连接可用可认为是普通数据，也可认为是优先级数据，大多数视之为普通数据。</li>
<li>非阻塞 <strong>connect</strong>的完成被认为是使相应套接字可写。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENTSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> listenfd = <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> reuseaddr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr, <span class="keyword">sizeof</span>(reuseaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"setsockopt: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = PF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">8008</span>);</span><br><span class="line">    inet_pton(PF_INET, <span class="string">"0.0.0.0"</span>, &amp;servaddr.sin_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(listenfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"bind: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">listen</span>(listenfd, <span class="number">5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"listen: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnoblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldopt = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> newopt = oldopt | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, newopt);</span><br><span class="line">    <span class="keyword">return</span> oldopt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfds</span>[<span class="title">CLIENTSIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = createSocket();</span><br><span class="line"></span><br><span class="line">    pfds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    pfds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">    pfds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> connnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = poll(pfds,connnum + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">// -1 will block</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"Error on poll\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connnum + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pfds[i].revents &amp; POLLHUP) || (pfds[i].revents &amp; POLLERR))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = pfds[i].fd;</span><br><span class="line">                <span class="built_in">close</span>(fd);</span><br><span class="line">                pfds[i--] = pfds[connnum--];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"delete connection: %d\n"</span>, fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pfds[i].fd == listenfd) &amp;&amp; (pfds[i].revents &amp; POLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                struct sockaddr_in client;</span><br><span class="line">                <span class="keyword">socklen_t</span> lenaddr = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">int</span> conn = <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == (conn = accept(listenfd, (struct sockaddr*)&amp;client, &amp;lenaddr)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"accept: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"New Connection %d from %s:%d\n"</span>, conn, inet_ntoa(client.sin_addr), client.sin_port);</span><br><span class="line">                connnum++;</span><br><span class="line">                setnoblock(conn);</span><br><span class="line"></span><br><span class="line">                pfds[connnum].fd = conn;</span><br><span class="line">                pfds[connnum].events = POLLIN | POLLHUP | POLLERR;</span><br><span class="line">                pfds[connnum].revents = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有可读数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pfds[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">int</span> lenrecv = recv(pfds[i].fd, buf, BUFSIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (lenrecv &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pfds[i].events &amp;= (~POLLIN);</span><br><span class="line">                    pfds[i].events |= POLLOUT;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Recv : %s\n"</span>,buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (lenrecv == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"------- client %d exit--------\n"</span>, pfds[i].fd);</span><br><span class="line">                    <span class="built_in">close</span>(pfds[i].fd);</span><br><span class="line">                    pfds[i--] = pfds[connnum--];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"recv: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可写数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pfds[i].revents &amp; POLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (send(pfds[i].fd,buf,<span class="built_in">strlen</span>(buf), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ECONNRESET == errno)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"send: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                pfds[i].events &amp;= (~POLLOUT);</span><br><span class="line">                pfds[i].events |= POLLIN;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h3><p>有很多方式来设置和影响套接字选项, 例如<code>getsockopt</code>, <code>setsockopt</code>, <code>fcntl</code>, <code>ioctl</code>,关于传输层的套接字选项, 请自行google或参考有关文档和书籍</p>
<h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p><img src="https://ae02.alicdn.com/kf/Ha628340ad172485e8d9ae24c2c7aff5dS.png" alt="img"></p>
<p>UDP编程模型</p>
<p>创建socket的时候要把<strong>SOCK_STREAM</strong>改成<strong>SOCK_DGRAM</strong></p>
<h3 id="recvfrom-和-sendto函数"><a href="#recvfrom-和-sendto函数" class="headerlink" title="recvfrom 和 sendto函数"></a>recvfrom 和 sendto函数</h3><p>类似与标准的read和write, 不过需要3个额外的参数: flags, from, addrlen, flags参数先不说, 暂时把他当成0, 后续会解释; from和addrlen参数和accept的最后两个参数类似</p>
<p>-<strong>注</strong>: 如果from是一个空指针, 那么addrlen也一样要是一个空指针, 表示我们不关心地址.</p>
<blockquote>
<p>`<strong>recvfrom</strong>和<strong>sendto</strong>都可以用于TCP, 尽管通常没有理由那么做*</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_echo</span><span class="params">(<span class="keyword">int</span> sockfd, SA* pcliaddr, <span class="keyword">socklen_t</span> clilen)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> mesg[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// `len` should be initialized to the size of the*</span></span><br><span class="line">		len = clilen;</span><br><span class="line">		n = recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, pcliaddr, &amp;len);</span><br><span class="line">    	sendto(sockfd, mesg, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> sockfd;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">  	sockfd  = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"> 	servaddr = makeAddr(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">  	bind(sockfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  	dg_echo(sockfd, (SA*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码虽简单, 但是有几个细节需要注意</p>
<ul>
<li><p>首先, 函数永不终止, 因为UDP是一个无连接的协议, 它没有像TCP中的EOF之类的东西</p>
</li>
<li><p>这是一个迭代服务器, 不像TCP服务器那样可以提供一个并发的服务器, 其中没有fork的调用,因此单个进程就得处理所有客户</p>
</li>
<li><p>对于本套接字, UDP层有排队发生, 事实上每个UDPsocket都有一个接收缓存区</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/13/TCP%E4%B8%AD%E7%9A%84Sequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/13/TCP%E4%B8%AD%E7%9A%84Sequence/" itemprop="url">
                  TCP 中的Sequence Number
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-13T21:41:57+08:00">
                2020-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://ae02.alicdn.com/kf/Hfe46670e16b74f51b00fa8c96b83ad52i.png" alt="img"></p>
<p>我们关注的就是<strong>序号</strong> 和 <strong>确认号</strong>，这二者也是 TCP 实现可靠传输的方式。</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>当某个主机开启一个TCP会话时，他的初始序列号是随机的，可能是0和4,294,967,295之间的任意值，然而，像Wireshark这种工具，通常显示的都是相对序列号/确认号，而不是实际序列号/确认号，相对序列号/确认号是和TCP会话的初始序列号相关联的。这是很方便的，因为比起真实序列号/确认号，跟踪更小的相对序列号/确认号会相对容易一些，通过序号的方式保存数据的顺序，接收端接受到之后进行重新排列。</p>
<p>因此，对于SEQ和ACK：<br>SEQ 代表：<strong>发送的这个包中第一个字节（如果有payload的话）的序号</strong><br>ACK 代表：<strong>已成功接受序列号到 ack-1 的数据，期望接收的下一个字节的序号为 ack</strong></p>
<p>举例说明：</p>
<blockquote>
<p>我已经发送了前100字节的数据，那么我下一个发送的包（如果发送窗口还有空间）的SEQ就是101，比如要发送10字节的数据，那么下一个包中的数据的字节编号就是 101 - 110. 之后如果继续发送的话，序号就是从111开始。</p>
</blockquote>
<blockquote>
<p>如果接收端接到了这个10字节的包的话，便会返回一个 ACK 为 111 的包，表示前面110个字节已经成功接收。</p>
</blockquote>
<h2 id="为什么SYN和FIN会消耗一个序列号"><a href="#为什么SYN和FIN会消耗一个序列号" class="headerlink" title="为什么SYN和FIN会消耗一个序列号"></a>为什么SYN和FIN会消耗一个序列号</h2><p>原因是 SYN 和 FIN 信号都是需要 acknowledgement 的，也就是你必须回复这个信号，如果它不占有一个字节（序列号）的话，要如何判断你是回复这个信号还是回复这个信号之前的包呢？</p>
<p>例如：如果 FIN 信号不占用一个字节（序列号），回复 FIN 的 ack 包就可能被误认为是回复之前的数据包被重新发送了一次，第二次挥手无法完成，连接也就无法正常关闭了。</p>
<p>从TCP的可靠传输角度来说，TCP是靠<strong>确认</strong>这个步骤来做到的，也就是Ack,用Ack来表示我这边已经收到了你发送的东西，包括数据和命令两部分，在可靠传输中用于建立和释放通道的就是命令。通道的建立需要双方进行协商，一方开始一个连接告知对方自己的数据，另一方则要对其进行确认，确认就是通过确认号来做。</p>
<p>而除了Syn和Fin的其他标志位，则不需要消耗一个序列号。首先Ack是为确认而生，如果给它一个序列号，则意味着还要对其自己进行确认，这就是一个死循环了。Rst标志位在使用的使用，也就表示TCP的可靠连接结束了，自然没有必要再去消耗序列号，进行确认。</p>
<p>总之TCP的整个过程，我们需要确认Syn和Fin两个命令。</p>
<h2 id="为什么SYN和ACK的初始值（ISN-initialization-sequence-number）是一个随机值"><a href="#为什么SYN和ACK的初始值（ISN-initialization-sequence-number）是一个随机值" class="headerlink" title="为什么SYN和ACK的初始值（ISN initialization sequence number）是一个随机值"></a>为什么SYN和ACK的初始值（ISN initialization sequence number）是一个随机值</h2><blockquote>
<p>ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<strong>[<em>RFC793</em>]</strong>(<em><a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc793</a></em>)<strong>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL –* *[<em>Wikipedia语条</em>]</strong>(<em><a href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime</a></em>)<em>*），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</em></p>
</blockquote>
<h2 id="什么是TCP-segment-of-a-reassembled-PDU"><a href="#什么是TCP-segment-of-a-reassembled-PDU" class="headerlink" title="什么是TCP segment of a reassembled PDU"></a>什么是TCP segment of a reassembled PDU</h2><p><img src="https://ae01.alicdn.com/kf/H576e3f9ae19846eda83e94a5391daeacU.png" alt="img"></p>
<p>如图所示，在抓包的时候，经常会看到[TCP segment of a reassembled PDU ] 字样的包，这个代表数据在传输层被分包了。也就是代表包大小大于MTU，此处放一下MTU与MSS区别：</p>
<blockquote>
<p>MTU（Maximum Transmission Unit）最大传输单元，在TCP/IP协议族中，指的是IP数据报能经过一个物理网络的最大报文长度，其中包括了IP首部(从20个字节到60个字节不等)，一般以太网的MTU设为1500字节，加上以太帧首部的长度14字节，也就是一个以太帧不会超过1500+14 = 1514字节。*MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，更小的 MTU 意味着更低的网络延迟。每一个物理设备都有自己的 MTU，两个主机之间的 MTU 依赖于底层的网络能力，它由整个链路上 MTU 最小的物理设备决定。</p>
</blockquote>
<blockquote>
<p>MSS（Maximum Segment Size，最大报文段大小，指的是TCP报文（一种IP协议的上层协议）的最大数据报长度，其中不包括TCP首部长度。MSS由TCP链接的过程中由双方协商得出，其中SYN字段中的选项部分包括了这个信息。如果MSS+TCP首部+IP首部大于MTU，那么IP报文就会存在分片，如果小于，那么就可以不需要分片正常发送。</p>
</blockquote>
<p>因此，出现这种现象的原因就是你调用一次send的时候，send的数据比 MSS 还要打，因此就被协议栈进行了分包。</p>
<p>顺便说一下，IP数据包的分片是通过flag字段和offset字段共同完成的。</p>
<p>从图中可以看到，第6个和第5个包是同一个TCP报文被分成了两个包。如果我们点开看的话，可以看到两个报文的ACK序号都一样，并且这些报文的Sequence Number都不一样，并且后一个Sequence Number为前一个Sequence Number加上前一个报文大小再加上1 。这也是判断reassembled 的方式。</p>
<p>点开第6个包，可以看到它将5和6的数据整合起来了。</p>
<h2 id="为什么TCP要进行分片呢？明明IP协议会进行分片的？"><a href="#为什么TCP要进行分片呢？明明IP协议会进行分片的？" class="headerlink" title="为什么TCP要进行分片呢？明明IP协议会进行分片的？"></a>为什么TCP要进行分片呢？明明IP协议会进行分片的？</h2><ul>
<li>IP 协议会分片传输过大的数据包（Packet）避免物理设备的限制；</li>
<li>TCP 协议会分段传输过大的数据段（Segment）保证传输的性能；</li>
</ul>
<p>路径最大传输单元发现（Path MTU Discovery，PMTUD）是用来确定两个主机传输路径 MTU 的机制，它的工作原理如下：</p>
<ol>
<li>向目的主机发送 IP 头中 DF 控制位为 1 的数据包，DF 是不分片（Don’t Fragment，DF）的缩写；</li>
<li>路径上的网络设备根据数据包的大小和自己的 MTU 做出不同的决定：<ol>
<li>如果数据包大于设备的 MTU，就会丢弃数据包并发回一个包含该设备 MTU 的 ICMP 消息；</li>
<li>如果数据包小于设备的 MTU，就会继续向目的主机传递数据包；</li>
</ol>
</li>
<li>源主机收到 ICMP 消息后，会不断使用新的 MTU 发送 IP 数据包，直到 IP 数据包达到目的主机；</li>
</ol>
<blockquote>
<p>ICMP 是互联网控制消息协议（Internet Control Message Protocol，ICMP），它能在 IP 主机之间传递控制消息。</p>
</blockquote>
<p>以太网对数据帧的限制一般都是 1500 字节，在一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输。</p>
<p>IP 协议数据分片对传输层协议是透明的，假设我们使用 UDP 协议传输 2000 字节的数据，加上 UDP 8 字节的协议头，IP 协议需要传输 2008 字节的数据。如下图所示，当 IP 协议发现待传输的数据大于 1480 字节，就会将数据分成下面的两个数据包：</p>
<p><img src="https://img.draveness.me/2020-02-12-15814868931890-udp-ip-packet.png" alt="img"></p>
<p><strong>分片传输的 UDP 数据</strong></p>
<ol>
<li>20 字节 IP 协议头 + 8 字节 UDP 协议头 + 1472 字节数据；</li>
<li>20 字节 IP 协议头 + 528 字节数据；</li>
</ol>
<p>数据的接收方在收到数据包时会对分片的数据进行重组，不过因为第二个数据包中不包含 UDP 协议的相关信息，一旦发生丢包，整个 UDP 数据报就无法重新拼装。如果 UDP 数据报需要传输的数据过多，那么 IP 协议就会大量分片，增加了不稳定性。</p>
<p>如果 IP 协议没有数据包大小的限制，那么上层可以以消息为单位传输数据，自然就不存在分片和组装的需求，不过因为物理设备的 MTU 限制，想要保证数据传输的可靠性和稳定性还需要传输层的配合。</p>
<h4 id="最大分段大小"><a href="#最大分段大小" class="headerlink" title="最大分段大小"></a>最大分段大小</h4><p>TCP 协议是面向字节流的协议，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机发送，应用层交给 TCP 协议发送的数据可能会被拆分到多个数据段中。</p>
<p>TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 连接的 MSS 是 MTU - 40 字节，即 1460 字节；不过如果通信双方没有指定 MSS 的话，在默认情况下 MSS 的大小是 536 字节。</p>
<p>IP 协议的 MTU 是物理设备上的限制，它限制了路径能够发送数据包的上限，而 TCP 协议的 MSS 是操作系统内核层面的限制，通信双方会在三次握手时确定这次连接的 MSS。一旦确定了 MSS，TCP 协议就会对应用层交给 TCP 协议发送的数据进行拆分，构成多个数据段。</p>
<p>需要注意的是，IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包（Package）为单位组织数据，而 TCP 协议以数据段（Segment）为单位组织数据。</p>
<p>如下图所示，如果 TCP 连接的 MSS 是 1460 字节，应用层想要通过 TCP 协议传输 2000 字节的数据，那么 TCP 协议会根据 MSS 将 2000 字节的数据拆分到两个数据段中：</p>
<p><img src="https://img.draveness.me/2020-02-12-15814868931896-tcp-ip-packet.png" alt="tcp-ip-packet"></p>
<p><strong>图 4 - 分段传输的 TCP 数据</strong></p>
<ul>
<li>20 字节 IP 头 + 20 字节 TCP 头 + 1460 字节数据；</li>
<li>20 字节 IP 头 + 20 字节 TCP 头 + 540 字节数据；</li>
</ul>
<p>从应用层的角度来看，两个数据段中 2000 字节的数据构成了发送方想要发送的消息，但是 TCP 协议是面向字节流的，向协议写入的数据会以流的形式传递到对端。</p>
<p>TCP 协议为了保证可靠性，会通过 IP 协议的 MTU 计算出 MSS 并根据 MSS 分段避免 IP 协议对数据包进行分片。因为 IP 协议对数据包的分片对上层是透明的，如果协议不根据 MTU 做一些限制，那么 IP 协议的分片会导致部分数据包失去传输层协议头，一旦数据包发生丢失就只能丢弃全部数据。</p>
<p>我们可以通过一个例子分析 MSS 存在的必要性。如下图所示，假设 TCP 协议中不存在 MSS 的概念，因为每个数据段的大小没有上限，当 TCP 协议交给 IP 层发送两个 1600 字节（包括 IP 和 TCP 协议头）的数据包时，由于物理设备的限制，IP 协议的路径 MTU 为 1500 字节，所以 IP 协议会对数据包分片：</p>
<p><img src="https://img.draveness.me/2020-02-12-15814868931902-tcp-ip-packet-with-ip-fragmentation.png" alt="tcp-ip-packet-with-ip-fragmentation"></p>
<p><strong>图 4 - 分片传输的 TCP 数据</strong></p>
<p>四个数据包中只有两个会包含 TCP 协议头，即控制位、序列号等信息，剩下的两个数据包中不包含任何信息。当 IP 协议传输数据丢包时，TCP 协议的接收方没有办法对数据包进行重组，所以整个 TCP 数据段都需要重传，带来了更多额外的重传和重组开销。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据拆分的根本原因说到底还是物理设备的限制，不过每一层协议都受限于下一层协议做出的决定，并依赖下层协议重新决定设计和实现的方法。虽然 TCP/IP 协议在传输数据时都需要对数据进行拆分，但是它们做出拆分数据的设计基于不同的上下文，也有着不同的目的，我们在这里总结一下两个网络协议做出类似决定的原因：</p>
<ul>
<li>IP 协议拆分数据是因为物理设备的限制，一次能够传输的数据由路径上 MTU 最小的设备决定，一旦 IP 协议传输的数据包超过 MTU 的限制就会发生丢包，所以我们需要通过路径 MTU 发现获取传输路径上的 MTU 限制；</li>
<li>TCP 协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头，如果数据段大小超过了 IP 协议的 MTU 限制， 就会带来更多额外的重传和重组开销，影响性能。</li>
</ul>
<p>通过本文的分析，相信各位读者不仅了解了为什么 TCP/IP 协议会拆分数据，也了解了为什么 UDP 协议的数据报不应该超过 MTU - 28 字节，一旦超过该限制，IP 协议的分片机制会增加 UDP 数据报无法重组的可能性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url">
                  计算机网络基础知识总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-11T10:30:57+08:00">
                2020-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="阅读目录"><a href="#阅读目录" class="headerlink" title="阅读目录"></a>阅读目录</h3><ol>
<li><p>网络层次划分</p>
</li>
<li><p>OSI七层网络模型</p>
</li>
<li><p>IP地址</p>
</li>
<li><p>子网掩码及网络划分</p>
</li>
<li><p>ARP/RARP协议</p>
</li>
<li><p>路由选择协</p>
</li>
<li><p>TCP/IP协议</p>
</li>
<li><p>UDP协议　</p>
</li>
<li><p>DNS协议</p>
</li>
<li><p>NAT协议</p>
</li>
<li><p>DHCP协议</p>
</li>
<li><p>HTTP协议</p>
</li>
<li><p>一个举例</p>
</li>
</ol>
<p>计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。一个很形象地比喻就是我们的语言，我们大天朝地广人多，地方性语言也非常丰富，而且方言之间差距巨大。A地区的方言可能B地区的人根本无法接受，所以我们要为全国人名进行沟通建立一个语言标准，这就是我们的普通话的作用。同样，放眼全球，我们与外国友人沟通的标准语言是英语，所以我们才要苦逼的学习英语。</p>
<p>计算机网络协议同我们的语言一样，多种多样。而ARPA公司与1977年到1979年推出了一种名为ARPANET的网络协议受到了广泛的热捧，其中最主要的原因就是它推出了人尽皆知的TCP/IP标准网络协议。</p>
<h3 id="1、网络层次划分"><a href="#1、网络层次划分" class="headerlink" title="1、网络层次划分"></a>1、网络层次划分</h3><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p>
<p>除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议。</p>
<h3 id="2、OSI七层网络模型"><a href="#2、OSI七层网络模型" class="headerlink" title="2、OSI七层网络模型"></a>2、OSI七层网络模型</h3><p>TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。</p>
<p><img src="https://ae01.alicdn.com/kf/Hd3267d5c6e93432d90b39abc5f939156Z.jpg" alt="img"></p>
<p><strong>1）物理层（Physical Layer）</strong></p>
<p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong>物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p>
<p><strong>2）数据链路层（Data Link Layer）</strong></p>
<p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p>
<p>有关数据链路层的重要知识点：</p>
<p><strong>1&gt; 数据链路层为网络层提供可靠的数据传输；</strong></p>
<p><strong>2&gt; 基本数据单位为帧；</strong></p>
<p><strong>3&gt; 主要的协议：以太网协议；</strong></p>
<p><strong>4&gt; 两个重要设备名称：网桥和交换机。</strong></p>
<p><strong>3）网络层（Network Layer）</strong></p>
<p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。</p>
<p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p>
<p><strong>1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</strong></p>
<p><strong>2&gt; 基本数据单位为IP数据报；</strong></p>
<p><strong>3&gt; 包含的主要协议：</strong></p>
<p><strong>IP协议（Internet Protocol，因特网互联协议）;</strong></p>
<p><strong>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</strong></p>
<p><strong>ARP协议（Address Resolution Protocol，地址解析协议）;</strong></p>
<p><strong>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</strong></p>
<p><strong>4&gt; 重要的设备：路由器。</strong></p>
<p><strong>4）传输层（Transport Layer）</strong></p>
<p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p>
<p>传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p>
<p>网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</p>
<p>有关网络层的重点：</p>
<p><strong>1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</strong></p>
<p><strong>2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；</strong></p>
<p><strong>3&gt; 重要设备：网关。</strong></p>
<p><strong>5）会话层</strong></p>
<p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<p><strong>6）表示层</strong></p>
<p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<p><strong>7）应用层</strong></p>
<p>为操作系统或网络应用程序提供访问网络服务的接口。</p>
<p>会话层、表示层和应用层重点：</p>
<p><strong>1&gt; 数据传输基本单位为报文；</strong></p>
<p><strong>2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</strong></p>
<h3 id="3、IP地址"><a href="#3、IP地址" class="headerlink" title="3、IP地址"></a>3、IP地址</h3><p><strong>1）网络地址</strong></p>
<p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p>
<p><strong>2）广播地址</strong></p>
<p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p>
<p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p>
<p><strong>3）组播地址</strong></p>
<p>D类地址就是组播地址。</p>
<p>先回忆下A，B，C，D类地址吧：</p>
<p>A类地址以00开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p>
<p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p>
<p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p>
<p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p>
<p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p>
<p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p>
<p><strong>4）255.255.255.255</strong></p>
<p>该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p>
<p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p>
<p><strong>5）0.0.0.0</strong></p>
<p>常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p>
<p><strong>6）回环地址</strong></p>
<p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p>
<p><strong>7）A、B、C类私有地址</strong></p>
<p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p>
<p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p>
<p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p>
<p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p>
<h3 id="4、子网掩码及网络划分"><a href="#4、子网掩码及网络划分" class="headerlink" title="4、子网掩码及网络划分"></a>4、子网掩码及网络划分</h3><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p>
<p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p>
<p><strong>什么是子网掩码？</strong></p>
<p>子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</p>
<p><strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即“ 0”地址和广播地址，它们是指主机地址或网络地址全为“ 0”或“ 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p>
<p><strong>子网掩码的计算：</strong></p>
<p>对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。</p>
<p>下面总结一下有关子网掩码和网络划分常见的面试考题：</p>
<p><strong>1）利用子网数来计算</strong></p>
<p>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p>
<p>(1) 将子网数目转化为二进制来表示;</p>
<p>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p>
<p>(2) 取得该二进制的位数，为N；</p>
<p>该二进制为五位数，N = 5</p>
<p>(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。</p>
<p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0</p>
<p><strong>2）利用主机数来计算</strong></p>
<p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p>
<p>(1) 将主机数目转化为二进制来表示；</p>
<p>700=1010111100；</p>
<p>(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；</p>
<p>该二进制为十位数，N=10；</p>
<p>(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p>
<p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</p>
<p><strong>3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和**</strong>计算子网掩码。这也可按上述原则进行计算。**</p>
<p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p>
<p>10＋1＋1＋1＝13</p>
<p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网**</strong>络地址和广播地址。**</p>
<p>因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p>
<p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p>
<h3 id="5、ARP-RARP协议"><a href="#5、ARP-RARP协议" class="headerlink" title="5、ARP/RARP协议"></a>5、ARP/RARP协议</h3><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。<strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p>
<p>ARP工作流程举例：</p>
<p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p>
<p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p>
<p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p>
<p>（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</p>
<p>（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p>
<p>（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p>
<p>（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p>
<p>（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p>
<p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p>
<p>RARP协议工作流程：</p>
<p>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p>
<p>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p>
<p>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p>
<p>（4）如果不存在，RARP服务器对此不做任何的响应；</p>
<p>（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p>
<h3 id="6、路由选择协议"><a href="#6、路由选择协议" class="headerlink" title="6、路由选择协议"></a>6、路由选择协议</h3><p>常见的路由选择协议有：RIP协议、OSPF协议。</p>
<p><strong>RIP**</strong>协议** ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p>
<p><strong>OSPF**</strong>协议** ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p>
<h3 id="7、TCP-IP协议"><a href="#7、TCP-IP协议" class="headerlink" title="7、TCP/IP协议"></a>7、TCP/IP协议</h3><p><strong>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p>
<p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p>
<p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p>
<p><strong>TCP报文首部格式：</strong></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>TCP协议的三次握手和四次挥手：</strong></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>注：seq</strong>:”sequance”序列号；<strong>ack</strong>:”acknowledge”确认号；<strong>SYN</strong>:”synchronize”请求同步标志；<strong>；ACK</strong>:”acknowledge”确认标志”<strong>；**</strong>FIN**：”Finally”结束标志。</p>
<p><strong>TCP连接建立过程：</strong>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p>
<p><strong>TCP连接断开过程：</strong>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p><strong>为什么要三次挥手？</strong></p>
<p>在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！</p>
<p><strong>为什么要四次挥手？</strong></p>
<p>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p>
<p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p>
<h3 id="8、UDP协议"><a href="#8、UDP协议" class="headerlink" title="8、UDP协议　"></a>8、UDP协议　</h3><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。**</strong>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。**</p>
<p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p>
<p>每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：</p>
<p>（1）源端口号；</p>
<p>（2）目标端口号；</p>
<p>（3）数据报长度；</p>
<p>（4）校验值。</p>
<p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p>
<p><strong>TCP</strong> <strong>与</strong> <strong>UDP</strong> <strong>的区别：</strong>TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</p>
<h3 id="9、DNS协议"><a href="#9、DNS协议" class="headerlink" title="9、DNS协议"></a>9、DNS协议</h3><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，<strong>可以简单地理解为将URL转换为IP地址</strong>。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。</p>
<h3 id="10、NAT协议"><a href="#10、NAT协议" class="headerlink" title="10、NAT协议"></a>10、NAT协议</h3><p>NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p>
<h3 id="11、DHCP协议"><a href="#11、DHCP协议" class="headerlink" title="11、DHCP协议"></a>11、DHCP协议</h3><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h3 id="12、HTTP协议"><a href="#12、HTTP协议" class="headerlink" title="12、HTTP协议"></a>12、HTTP协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p>
<p><strong>HTTP</strong> <strong>协议包括哪些请求？</strong></p>
<p>GET：请求读取由URL所标志的信息。</p>
<p>POST：给服务器添加信息（如注释）。</p>
<p>PUT：在给定的URL下存储一个文档。</p>
<p>DELETE：删除给定的URL所标志的资源。</p>
<p><strong>HTTP</strong> <strong>中，</strong> <strong>POST</strong> <strong>与</strong> <strong>GET</strong> <strong>的区别</strong></p>
<p>1）Get是从服务器上获取数据，Post是向服务器传送数据。</p>
<p>2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</p>
<p>3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</p>
<p>4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>
<p>I. 所谓 <strong>安全的</strong> 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p>
<p>II. <strong>幂等</strong> 的意味着对同一URL的多个请求应该返回同样的结果。</p>
<h3 id="13、一个举例"><a href="#13、一个举例" class="headerlink" title="13、一个举例"></a>13、一个举例</h3><p><strong>在浏览器中输入</strong> <strong><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> <strong>后执行的全部过程</strong></p>
<p>现在假设如果我们在客户端（客户端）浏览器中输入<a href="http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：">http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</a></p>
<p>1）客户端浏览器通过DNS解析到<a href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。" target="_blank" rel="noopener">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
<p>2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
<p>3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p>4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/std_enable_if/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/06/07/std_enable_if/" itemprop="url">
                  std::enable_if
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-07T20:35:57+08:00">
                2020-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>SFINAE是英文Substitution failure is not an error的缩写，意思是匹配失败不是错误。这句话什么意思呢？当调用模板函数时编译器会根据传入参数推导最合适的模板函数，在这个推导过程中如果某一个或者某几个模板函数推导出来是编译无法通过的，只要有一个可以正确推导出来，那么那几个推导得到的可能产生编译错误的模板函数并不会引发编译错误</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">typename</span> T::foo)</span> </span>&#123;&#125; <span class="comment">// Definition #1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;&#125;               <span class="comment">// Definition #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f&lt;Test&gt;(<span class="number">10</span>); <span class="comment">// Call #1.</span></span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);  <span class="comment">// Call #2. Without error (even though there is no int::foo) thanks to SFINAE.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是wiki上SFINAE的一个经典示例，注释已经解释的相当明白，由于推导模板函数过程中可以找到一个正确的版本，所以即时int::foo是一个语法错误，但是编译器也不会报错。这就是SFINAE要义。在C++11中，标准确立了这种编译的行为，而不像C++98未明确定义它的行为。通过std::enable_if和SFINAE的共同使用，会产生很多很奇妙的实现，STL库中大量的应用了这种组合，下面我们来看看他们组合一起是如何工作的。</p>
</blockquote>
<blockquote>
<p>一个普通版本的模板类定义，一个偏特化版本的模板类定义。它在第一个模板参数为false的时候并不会定义type，只有在第一模板参数为true的时候才会定义type。看一下下面的模板实例化代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">true</span>, <span class="keyword">int</span>&gt;::type t; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">true</span>&gt;::type;        <span class="comment">//可以通过编译，没有实际用处，推导的模板是偏特化版本，第一模板参数是true，第二模板参数是通常版本中定义的默认类型即void</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">false</span>&gt;::type;       <span class="comment">//无法通过编译，type类型没有定义</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">false</span>, <span class="keyword">int</span>&gt;::type t2; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以看到，通过typename std::enable_if<bool>::type这样传入一个bool值，就能推导出这个type是不是未定义的。那么这种用法有什么用途呢？结合上面的SFINAE来看代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_trivial&lt;T&gt;::value&gt;::<span class="function">type <span class="title">SFINAE_test</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"T is trival"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;!<span class="built_in">std</span>::is_trivial&lt;T&gt;::value&gt;::<span class="function">type <span class="title">SFINAE_test</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"T is none trival"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">SFINAE_test(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"123"</span>));</span><br><span class="line">SFINAE_test(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这两个函数如果是普通函数的话，根据重载的规则是不会通过编译的。即便是模板函数，如果这两个函数都能推导出正确的结果，也会产生重载二义性问题，但是正因为std::enable_if的运用使这两个函数的返回值在同一个函数调用的推导过程中只有一个合法，遵循SFINAE原则，则可以顺利通过编译。</p>
</blockquote>
<blockquote>
<p>当第一个函数调用进行模板函数推导的时候，第一个版本的模板函数std::is_trivial<T>::value为false，继而std::enable_if&lt;std::is_trivial<T>::value&gt;::type这个类型未定义，不能正确推导，编译器区寻找下一个可能的实现，所以接下来找到第二个模板函数，!std::is_trivial<T>::value的值是true，继而std::enable_if&lt;std::is_trivial<T>::value&gt;::type是void类型，推导成功。这时候SFINAE_test(std::string(“123”));调用有了唯一确定的推导，即第二个模板函数，所以程序打印T is none trival。与此相似的过程，第二个函数调用打印出T is trival。<br>这样写的好处是什么？这个例子中可以认为我们利用SFINAE特性实现了通过不同返回值，相同函数参数进行了函数重载，这样代码看起来更统一一些。还有一些其他应用std::enable_if的方式，比如在模板参数列表里，在函数参数列表里，都是利用SFINAE特性来实现某一些函数的选择推导。来看一下cpprefrence上的例子代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> detail &#123; <span class="class"><span class="keyword">struct</span> <span class="title">inplace_t</span>&#123;</span>&#125;; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">void</span>* p, detail::<span class="keyword">inplace_t</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// enabled via the return type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;<span class="built_in">std</span>::is_trivially_constructible&lt;T,Args&amp;&amp;...&gt;::value&gt;::type </span><br><span class="line">    construct(T* t,Args&amp;&amp;... args) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing trivially constructible T\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// enabled via a parameter</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span>* <span class="title">t</span>, </span></span><br><span class="line"><span class="class">             <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;<span class="built_in">std</span>::is_trivially_destructible&lt;T&gt;::value&gt;::type* = <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroying trivially destructible T\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// enabled via a template parameter</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">         <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">             !<span class="built_in">std</span>::is_trivially_destructible&lt;T&gt;&#123;&#125; &amp;&amp;</span><br><span class="line">             (<span class="built_in">std</span>::is_class&lt;T&gt;&#123;&#125; || <span class="built_in">std</span>::is_union&lt;T&gt;&#123;&#125;),</span><br><span class="line">            <span class="keyword">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">void</span> destroy(T* t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroying non-trivially destructible T\n"</span>;</span><br><span class="line">    t-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">aligned_union_t</span>&lt;<span class="number">0</span>,<span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; u;</span><br><span class="line"> </span><br><span class="line">    construct(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;u));</span><br><span class="line">    destroy(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;u));</span><br><span class="line"> </span><br><span class="line">    construct(<span class="keyword">reinterpret_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt;(&amp;u),<span class="string">"Hello"</span>);</span><br><span class="line">    destroy(<span class="keyword">reinterpret_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt;(&amp;u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/std_string_wstring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/27/std_string_wstring/" itemprop="url">
                  std_string_wstring
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-27T20:51:33+08:00">
                2020-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="std-string-std-wstring"><a href="#std-string-std-wstring" class="headerlink" title="std::string std::wstring"></a>std::string std::wstring</h3><p><strong>std::string 与 std::wstring 转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ws2s</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> &amp;ws)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> curLocale = setlocale(LC_ALL, <span class="literal">NULL</span>);</span><br><span class="line">    setlocale(LC_ALL, <span class="string">"chs"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span>* _source = ws.c_str();</span><br><span class="line">    <span class="keyword">size_t</span> _dsize = <span class="number">2</span> * ws.size() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* _dest = <span class="keyword">new</span> <span class="keyword">char</span>[_dsize];</span><br><span class="line">    <span class="built_in">memset</span>(_dest, <span class="number">0x0</span>, _dsize);</span><br><span class="line">    wcstombs_s(&amp;i, _dest, _dsize, _source, _dsize);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = _dest;</span><br><span class="line">    <span class="keyword">delete</span>[] _dest;</span><br><span class="line">    setlocale(LC_ALL, curLocale.c_str());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">s2ws</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> curLocale = setlocale(LC_ALL, <span class="literal">NULL</span>);</span><br><span class="line">    setlocale(LC_ALL, <span class="string">"chs"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* _source = s.c_str();</span><br><span class="line">    <span class="keyword">size_t</span> _dsize = s.size() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span>* _dest = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[_dsize];</span><br><span class="line">    wmemset(_dest, <span class="number">0x0</span>, _dsize);</span><br><span class="line">    mbstowcs_s(&amp;i, _dest, _dsize, _source, _dsize);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> result = _dest;</span><br><span class="line">    <span class="keyword">delete</span>[] _dest;</span><br><span class="line">    setlocale(LC_ALL, curLocale.c_str());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;codecvt&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ws2s</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; src )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::locale <span class="title">sys_locale</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">wchar_t</span>* data_from = src.c_str();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">wchar_t</span>* data_from_end = src.c_str() + src.size();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">wchar_t</span>* data_from_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> wchar_size = <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>);</span><br><span class="line">	<span class="keyword">char</span>* data_to = <span class="keyword">new</span> <span class="keyword">char</span>[(src.size() + <span class="number">1</span>) * wchar_size];</span><br><span class="line">	<span class="keyword">char</span>* data_to_end = data_to + (src.size() + <span class="number">1</span>) * wchar_size;</span><br><span class="line">	<span class="keyword">char</span>* data_to_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>( data_to, <span class="number">0</span>, (src.size() + <span class="number">1</span>) * wchar_size );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::codecvt&lt;<span class="keyword">wchar_t</span>, <span class="keyword">char</span>, <span class="keyword">mbstate_t</span>&gt; convert_facet;</span><br><span class="line">	<span class="keyword">mbstate_t</span> out_state = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> result = <span class="built_in">std</span>::use_facet&lt;convert_facet&gt;(sys_locale).out(</span><br><span class="line">		out_state, data_from, data_from_end, data_from_next,</span><br><span class="line">		data_to, data_to_end, data_to_next );</span><br><span class="line">	<span class="keyword">if</span>( result == convert_facet::ok )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> dst = data_to;</span><br><span class="line">		<span class="keyword">delete</span>[] data_to;</span><br><span class="line">		<span class="keyword">return</span> dst;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">"convert error!\n"</span> );</span><br><span class="line">		<span class="keyword">delete</span>[] data_to;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">s2ws</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; src )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::locale <span class="title">sys_locale</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* data_from = src.c_str();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* data_from_end = src.c_str() + src.size();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* data_from_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">wchar_t</span>* data_to = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[src.size() + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">wchar_t</span>* data_to_end = data_to + src.size() + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">wchar_t</span>* data_to_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	wmemset( data_to, <span class="number">0</span>, src.size() + <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::codecvt&lt;<span class="keyword">wchar_t</span>, <span class="keyword">char</span>, <span class="keyword">mbstate_t</span>&gt; convert_facet;</span><br><span class="line">	<span class="keyword">mbstate_t</span> in_state = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> result = <span class="built_in">std</span>::use_facet&lt;convert_facet&gt;(sys_locale).in(</span><br><span class="line">		in_state, data_from, data_from_end, data_from_next,</span><br><span class="line">		data_to, data_to_end, data_to_next );</span><br><span class="line">	<span class="keyword">if</span>( result == convert_facet::ok )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">wstring</span> dst = data_to;</span><br><span class="line">		<span class="keyword">delete</span>[] data_to;</span><br><span class="line">		<span class="keyword">return</span> dst;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">"convert error!\n"</span> );</span><br><span class="line">		<span class="keyword">delete</span>[] data_to;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>(<span class="string">L""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ws2utf8</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; src )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::wstring_convert&lt;<span class="built_in">std</span>::codecvt_utf8&lt;<span class="keyword">wchar_t</span>&gt;&gt; conv;</span><br><span class="line">	<span class="keyword">return</span> conv.to_bytes( src );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">utf8_2_ws</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; src )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::wstring_convert&lt;<span class="built_in">std</span>::codecvt_utf8&lt;<span class="keyword">wchar_t</span>&gt; &gt; conv;</span><br><span class="line">	<span class="keyword">return</span> conv.from_bytes( src );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/25/%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" itemprop="url">
                  纯虚析构函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T20:25:15+08:00">
                2020-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>纯虚函数将产生抽象类——不能实例化的类（即不能创建此类型的对象）。当你想使一个类成为抽象类，刚好又没有任何纯虚函数。该怎么做？</strong><br><strong>因为抽象类是准备被用做基类的，基类必须要有一个虚析构函数，纯虚函数会产生抽象类，所以方法很简单：在想要成为抽象类的类里声明一个纯虚析构函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBase</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~AbstractBase() = <span class="number">0</span>; <span class="comment">// 声明一个纯虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AbstractBase::~AbstractBase()&#123;&#125;<span class="comment">//必须在类外进行定义</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span><span class="keyword">public</span> AbstractBase</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AbstractBase * p = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 触发基类的析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个类有一个纯虚函数，所以它是抽象的，而且它有一个虚析构函数，所以不会产生析构函数问题。</p>
</blockquote>
<blockquote>
<p>这个定义是必需的，因为虚析构函数工作的方式是：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。<br>这就是说，即使是抽象类，编译器也要产生对~AbstractBase的调用，但是，又由于父类的析构函数是纯虚函数，没有实现体，所以，当析构到父类时，由于没有实现体，所以导致父类无法析构，最终也导致了析构畸形，所以要保证为它提供函数体。如果不这么做，链接器就会检测出来。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/%E5%A5%87%E5%BC%82%E6%A8%A1%E6%9D%BF%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/18/%E5%A5%87%E5%BC%82%E6%A8%A1%E6%9D%BF%E9%80%92%E5%BD%92/" itemprop="url">
                  奇异模板递归
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-18T21:06:03+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-奇异模板递归"><a href="#C-奇异模板递归" class="headerlink" title="C++ 奇异模板递归"></a>C++ 奇异模板递归</h1><blockquote>
<p>奇异递归模板模式（curiously recurring template pattern，CRTP）是C++模板编程时的一种惯用法（idiom）：把派生类作为基类的模板参数。更一般地被称作F-bound polymorphism，是一类F 界量化，相关介绍可以参考 wiki 奇异递归模板模式。</p>
</blockquote>
<h2 id="CRTP的特点"><a href="#CRTP的特点" class="headerlink" title="CRTP的特点"></a>CRTP的特点</h2><ul>
<li>继承自模板类；</li>
<li>使用派生类作为模板参数特化基类；</li>
</ul>
<h2 id="CRTP基本范式"><a href="#CRTP基本范式" class="headerlink" title="CRTP基本范式"></a>CRTP基本范式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">// use the derived class itself as a template parameter of the base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;Derived&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样做的目的是在基类中使用派生类，从基类的角度来看，派生类其实也是基类，通过向下转换[downcast],因此，基类可以通过static_cast把其转换到派生类，从而使用派生类的成员，形式如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWhat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T&amp; derived = <span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// use derived...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 这里不使用dynamic_cast,因为dynamic_cast一般是为了确保在运行期(run-time)向上向下转换的正确性。CRTP的设计是：派生类就是基类的模板参数，因此static_cast足矣。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> :</span> <span class="keyword">public</span> Base&lt;Derived1&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> :</span> <span class="keyword">public</span> Base&lt;Derived1&gt; <span class="comment">// bug in this line of code</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建议这种写法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// import </span></span><br><span class="line">    Base()&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  The Curiously Recurring Template Pattern (CRTP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Expression</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">cast</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expands derived class interface by inheriting from the base class</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_absolute_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cast().set_value(<span class="built_in">abs</span>(cast().get_value()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cast().get_value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cast().get_result();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cast().sub_calc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Expression&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Expression&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Expression()&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Expression&lt;Square&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Square(<span class="keyword">double</span> val = <span class="number">0</span>, <span class="keyword">double</span> res = <span class="number">0</span>):val_(val),result_(res)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        val_ = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub_calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        result_ = val_*val_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> val_;</span><br><span class="line">    <span class="keyword">double</span> result_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sqrt</span> :</span> <span class="keyword">public</span> Expression&lt;Sqrt&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Sqrt(<span class="keyword">double</span> val = <span class="number">0</span>, <span class="keyword">double</span> res = <span class="number">0</span>) :val_(val), result_(res) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        val_ = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub_calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(val_&gt;=<span class="number">0</span>);</span><br><span class="line">        result_ = <span class="built_in">sqrt</span>(val_);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> val_;</span><br><span class="line">    <span class="keyword">double</span> result_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Static interfaces</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">T</span> <span class="title">is</span> <span class="title">deduced</span> <span class="title">at</span> <span class="title">compile</span>-<span class="title">time</span></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">OP</span>(<span class="title">Expression</span>&lt;T&gt; &amp;<span class="title">sq</span>, <span class="title">const</span> <span class="title">string</span>&amp; <span class="title">op</span>) &#123;</span></span><br><span class="line">    <span class="comment">// will do static dispatch</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Berfore OP this expression's value is:"</span> &lt;&lt; sq.value() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    sq.calc();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After OP "</span>&lt;&lt; op &lt;&lt;\</span><br><span class="line">        <span class="string">",  this expression's result is:"</span> &lt;&lt; sq.result() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Sqrt <span class="title">sqr</span><span class="params">(<span class="number">-2</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"this expression's value is:"</span> &lt;&lt; sqr.value() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// Adding functionality</span></span><br><span class="line">sqr.set_absolute_value();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After set absolute,  this expression's value is:"</span> &lt;&lt; sqr.value() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">OP(sqr, <span class="string">"Sqrt"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------\n"</span>;</span><br><span class="line"><span class="function">Square <span class="title">sq</span><span class="params">(<span class="number">-2</span>)</span></span>;</span><br><span class="line">OP(sq, <span class="string">"Square"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CRTP是一种静态多态（static polymorphism/Static binding/Compile-Time binding)与其对应的是动态多态(dynamic polymorphism/Dynamic binding/Run-Time binding)。<br>静态多态与和动态的区别是：多态是动态绑定（运行时绑定 run-time binding），CRTP是静态绑定（编译时绑定 compile-time binding）。其中，动态多态在实现多态时，需要重写虚函数，这种运行时绑定的操作往往需要查找虚表等，效率低。另，template的核心技术在于编译期多态机制，与运行期多态（runtime polymorphism）相比，这种动态机制提供想编译期多态性，给了程序运行期无可比拟的效率优势，因此，如果想在编译期确定通过基类来得到派生类的行为，CRTP便是一种绝佳的选择。</p>
</blockquote>
<p><em>std::enable_shared_from_this&lt;&gt;</em> 大法！！！ </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zhangyxin" />
          <p class="site-author-name" itemprop="name">zhangyxin</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangyxin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
