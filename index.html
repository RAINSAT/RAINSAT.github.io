<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hello, yxin" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="zhangyxin coder">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zhangyxin coder">
<meta property="article:author" content="zhangyxin">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> zhangyxin coder </title>
<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zhangyxin coder</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/UDP%E4%B8%AD%E7%9A%84connect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/15/UDP%E4%B8%AD%E7%9A%84connect/" itemprop="url">
                  UDP中的 connect
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-15T21:48:36+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>标准的udp客户端开了套接口后，一般使用<code>sendto</code>和<code>recvfrom</code>函数来发数据，但同样可以使用<code>send</code>函数进行发送。</p>
<p><strong>方法一</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket-----&gt;sendto()或recvfrom()</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket-----&gt;connect()-----&gt;send()或recv()</span><br></pre></td></tr></table></figure>

<p>在<strong>UDP</strong>中也是可以使用<strong>connect</strong>的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct sockaddr *to, <span class="keyword">socklen_t</span> tolen)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span>  s, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sockaddr *from,  <span class="keyword">socklen_t</span> *fromlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sendto</code>和<code>recvfrom</code>在收发时需要指定地址，而<code>send</code>和<code>recv</code>则没有，那么他们的地址是在那里指定的呢，答案就在于<code>connect</code>!!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_taddrlen);</span><br></pre></td></tr></table></figure>

<p>在UDP编程中，如果你只往一个地址发送，那么你可以使用<code>send</code>和<code>recv</code>，在使用它们之前用<code>connect</code>把它们的目的地址指定一下就可以了。<code>connect</code>函数在<code>UDP</code>中就是这个作用，用它来检测<code>UDP</code>端口的是否开放是没有用的。下面是<code>ntpclient</code>中的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa_dest</span>;</span></span><br><span class="line">bzero((<span class="keyword">char</span> *)sa_dest, <span class="keyword">sizeof</span>(*sa_dest));</span><br><span class="line">sa_dest-&gt;sin_family = AF_INET;</span><br><span class="line"><span class="keyword">if</span> (StuffNetAddr(&amp;(sa_dest-&gt;sin_addr), host))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">sa_dest-&gt;sin_port = htons(port);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(usd, (struct sockaddr *)&amp;sa_dest, <span class="keyword">sizeof</span>(sa_dest)) == <span class="number">-1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"connect"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>[unix网络编程8.11]除非套接口已连接，否则异步错误是不会返回到UDP套接口的，我们确实可以给UDP套接口调用connect，然而这样做的结果却与<strong>TCP连接大相径庭</strong>：没有三路握手过程。相反内核只是检查是否存在<strong>立即可知的错误</strong>(例如一个显然不可达的目的地)，记录对端的IP地址和端口号（取自传递给connect的套接口地址结构），然后立即返回到调用进程。</p>
</blockquote>
<p>对于<strong>已连接UDP套接口(对缺省的套接字调用connect)</strong>，与缺省的<strong>未连接套接口</strong>相比，发生了三个变化：</p>
<ol>
<li>我们再也<strong>不能给输出操作指定目的IP地址和端口号</strong>，也就是说我们不使用sendto，而改用write或send，写到已连接UDP套接口上的任何内容都自动发送到由connect指定的协议地址（例如IP地址和端口号）</li>
<li>我们不必使用<code>recvfrom</code>以获悉数据报的发送者，<strong>而改用read，recv或recvmsg</strong>，在一个已连接UDP套接口上由内核为输入操作返回的数据 报仅仅是那些来自connect所指定协议地址的数据报。目的地为这个已连接UDP套接口的本地协议地址，发源地却不是该套接口早先connect到的协 议地址的数据报，不会投递到该套接口。这样就限制了一个已连接UDP套接口而且仅能与一个对端交换数据报。</li>
<li>由已连接的UDP套接口引发的异步错误会返回给他们所在的进程。而未连接UDP套接字不接收任何错误。</li>
</ol>
<p>相反我们说过未连接UDP套接口不接收任何异步错误，给一个UDP套接口多次调用connect可以为下列2个目的之一：</p>
<ol>
<li>指定新的IP地址和端口号；</li>
<li>断开套接口</li>
</ol>
<p>第一个目的（即给一个已连接UDP套接口指定新的对端）不同于TCP套接口中connect的使用:对于TCP套接口，connect只能调用一次。</p>
<p>为了断开一个已connect的UDP套接口连接，我们再次调用connect时把套接口地址结构的地址簇成员（sin_family）设置为<code>AF_UNSPEC</code>。<br>这么做可能返回一个<code>EAFNOSUPPORT</code>错误，不过没有关系。<br>使得套接口断开连接的是在已连接UDP套接口上调用connect的进程。</p>
<p><strong>调用 connect 有如下的一些好处</strong>：</p>
<ol>
<li>选定了对端，内核只会将帮定对象的对端发来的数据报传给套接口，因此在一定环境下可以提升安全性；</li>
<li><strong>会返回异步错误</strong>，如果对端没启动，<strong>默认情况下发送的包对应的ICMP回射包不会给调用进程</strong>，如果用了connect，<strong>嘿嘿</strong></li>
<li>发送两个包间不会发生断开再连接，提升了效率。</li>
</ol>
<p>做个实验测试下吧</p>
<p>先弄个UDP回射服务器，把所有收到的数据报回射回去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>                sockListener, nMsgLen;</span><br><span class="line">    <span class="keyword">char</span>               szBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrListener</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>          addrLen;</span><br><span class="line">    addrLen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    bzero(&amp;addrListener, <span class="keyword">sizeof</span>(addrListener));</span><br><span class="line">    addrListener.sin_family = AF_INET;</span><br><span class="line">    addrListener.sin_port   = htons(<span class="number">8000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((sockListener = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"error in getting a socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (bind(sockListener, (struct sockaddr *)&amp;addrListener,</span><br><span class="line">             <span class="keyword">sizeof</span>(addrListener)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind a listener for a socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrClient</span>;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"start listenning"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        nMsgLen = recvfrom(sockListener, szBuf, <span class="number">1024</span>, <span class="number">0</span>,</span><br><span class="line">                           (struct sockaddr *)&amp;addrClient, &amp;addrLen);</span><br><span class="line">        <span class="keyword">if</span> (nMsgLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            szBuf[nMsgLen] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"send back:"</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            sendto(sockListener, szBuf, nMsgLen, <span class="number">0</span>,</span><br><span class="line">                   (struct sockaddr *)&amp;addrClient, addrLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写个客户端，绑定个端口，再连接服务器端。随时接受键盘输入并发送到服务器端，随时接受端口到来的数据并打印。如果没有连接 ，发送到此端口的数据会被接受，但是调用connect后会怎样呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>                sockClient, nMsgLen, nReady;</span><br><span class="line">    <span class="keyword">char</span>               szRecv[<span class="number">1024</span>], szSend[<span class="number">1024</span>], szMsg[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrServer</span>, <span class="title">addrClient</span>, <span class="title">addrLocal</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>          addrLen;</span><br><span class="line">    fd_set             setHold, setTest;</span><br><span class="line"> </span><br><span class="line">    sockClient = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    addrLen    = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    bzero(&amp;addrServer, <span class="keyword">sizeof</span>(addrServer));</span><br><span class="line">    addrServer.sin_family      = AF_INET;</span><br><span class="line">    addrServer.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    addrServer.sin_port        = htons(<span class="number">8000</span>);</span><br><span class="line"> </span><br><span class="line">    addrLocal.sin_family      = AF_INET;  <span class="comment">// bind to a local port</span></span><br><span class="line">    addrLocal.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addrLocal.sin_port        = htons(<span class="number">9000</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockClient, (struct sockaddr *)&amp;addrLocal, <span class="keyword">sizeof</span>(addrLocal)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"error in binding"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockClient, (struct sockaddr *)&amp;addrServer,</span><br><span class="line">                <span class="keyword">sizeof</span>(addrServer)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"error in connecting"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    FD_ZERO(&amp;setHold);</span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;setHold);</span><br><span class="line">    FD_SET(sockClient, &amp;setHold);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"you can type in sentences any time"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        setTest = setHold;</span><br><span class="line">        nReady  = select(sockClient + <span class="number">1</span>, &amp;setTest, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(<span class="number">0</span>, &amp;setTest)) &#123;</span><br><span class="line">            nMsgLen = <span class="built_in">read</span>(<span class="number">0</span>, szMsg, <span class="number">1024</span>);</span><br><span class="line">            <span class="built_in">write</span>(sockClient, szMsg, nMsgLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockClient, &amp;setTest)) &#123;</span><br><span class="line">            nMsgLen         = <span class="built_in">read</span>(sockClient, szRecv, <span class="number">1024</span>);</span><br><span class="line">            szRecv[nMsgLen] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"read:"</span> &lt;&lt; szRecv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来个“第三者”，向第二个的端口发数据报。看她会不会成为忠贞的感情守护人:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">socklen_t</span>          addrLen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrServer</span>;</span></span><br><span class="line">    <span class="keyword">char</span>               szMsg[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span>                sockClient;</span><br><span class="line"> </span><br><span class="line">    addrServer.sin_family      = AF_INET;</span><br><span class="line">    addrServer.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    addrServer.sin_port        = htons(<span class="number">9000</span>);</span><br><span class="line"> </span><br><span class="line">    sockClient = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">snprintf</span>(szMsg, <span class="keyword">sizeof</span>(szMsg), <span class="string">"this is %d"</span>, id++);</span><br><span class="line">        sendto(sockClient, szMsg, <span class="built_in">strlen</span>(szMsg), <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;addrServer, <span class="keyword">sizeof</span>(addrServer));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现运行第一个程序，再运行第三个程序，然后运行第二个程序。</p>
<p>服务器端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">callback server begin to listen</span><br><span class="line">send back:xinheblue likes playing</span><br><span class="line"> </span><br><span class="line">send back:and listenning to music</span><br></pre></td></tr></table></figure>

<p>第二个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">you can type in sentences any time</span><br><span class="line">xinheblue likes playing</span><br><span class="line">read:xinheblue likes playing</span><br><span class="line"> </span><br><span class="line">and listenning to music</span><br><span class="line">read:and listenning to music</span><br></pre></td></tr></table></figure>

<p>实现结果证明，第二个程序调用connect后，不接收第三个程序发来的数据包。</p>
<h2 id="udp客户端-用不用-bind-的区别"><a href="#udp客户端-用不用-bind-的区别" class="headerlink" title="udp客户端 用不用 bind 的区别"></a>udp客户端 用不用 bind 的区别</h2><p>无连接的socket的客户端和服务端以及面向连接socket的服务端通过调用bind函数来配置本地信息。使用bind函数时，通过将my_addr.sin_port置为0，函数会自动为你选择一个未占用的端口来使用。<br>Bind()函数在成功被调用时返回0；出现错误时返回”-1”并将errno置为相应的错误号。需要注意的是，在调用bind函数时一般不要将端口号置为小于1024的值，因为1到1024是保留端口号，你可以选择大于1024中的任何一个没有被占用的端口号。</p>
<p>有连接的socket客户端通过调用Connect函数在socket数据结构中保存本地和远端信息，无须调用bind()，因为这种情况下只需知道目的机器的IP地址，而客户通过哪个端口与服务器建立连接并不需要关心，socket执行体为你的程序自动选择一个未被占用的端口，并通知你的程序数据什么时候打开端口。（当然也有特殊情况，linux系统中rlogin命令应当调用bind函数绑定一个未用的保留端口号，还有当客户端需要用指定的网络设备接口和端口号进行通信等等）<br>总之：</p>
<ol>
<li>需要在建连前就知道端口的话，需要 bind</li>
<li>需要通过指定的端口来通讯的话，需要 bind</li>
</ol>
<p>具体到上面那两个程序，本来用的是TCP，客户端就不用绑定端口了，绑定之后只能运行一个client的程序属于自己人为设定的障碍，而从服务器那边得到的客户机连接端口号（是系统自动分配的）与这边客户机绑定的端口号根本是不相关的，所以客户端绑定也就失去了意义。</p>
<p>首先，服务器和客户端都可以bind，bind并不是服务器的专利。<br>客户端进程bind端口： 由进程选择一个端口去连服务器，（如果默认情况下，调用bind函数时，内核指定的端口是同一个，那么调用多个调用了bind（）的client程序，会出现端口被占用的错误）注意这里的端口是客户端的端口。如果不分配就表示交给内核去选择一个可用端口。<br>客户端进程bind IP地址：相当于为发送出去的IP数据报分配了源IP地址，但交给进程分配IP地址的时候（就是这样写明了bind IP地址的时候）这个IP地址必须是主机的一个接口，不能分配一个不存在的IP。如果不分配就表示由内核根据所用的输出接口来选择源IP地址。</p>
<p>一般情况下客户端是不用调用bind函数的，一切都交给内核搞定！</p>
<p>服务端进程bind端口：基本是必须要做的事情，比如一个服务器启动时（比如freebsd），它会一个一个的捆绑众所周知的端口来提供服务，同样，如果bind了一个端口就表示我这个服务器会在这个端口提供一些“特殊服务”。<br>服务端进程bind IP地址：目的是限制了服务端进程创建的socket只接受那些目的地为此IP地址的客户链接，一般一个服务器程序里都有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// 只是针对IP4，IP6代码不太一样</span></span><br></pre></td></tr></table></figure>

<p>这样一句话，意思就是：我不指定客户端的IP，随便连，来者不拒！</p>
<p>总之只要你bind时候没有指定哪一项（置为0），内核会帮你选择。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/14/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/14/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url">
                  Unix网络编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-14T20:20:17+08:00">
                2020-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="传输层部分知识点"><a href="#传输层部分知识点" class="headerlink" title="传输层部分知识点"></a>传输层部分知识点</h2><h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><ul>
<li>MSL: maximum segment lifetime</li>
</ul>
<p>任何TCP的实现都需要为MSL选择一个合适的值, RFC的建议值是2分钟。分组可能出现迷途，若迷途分组在MSL中找到路， 造成重复，TCP必须修复</p>
<p><code>TIME_WAIT</code>存在的理由:</p>
<ol>
<li><p><strong>可靠的实现全双工的连接和终止</strong><br> 考虑最终<code>ACK</code>丢失的情况,</p>
</li>
<li><p><strong>允许老的重复分组在网络中消逝</strong></p>
<p>TCP的化生身现象, 因为<code>TIME_WAIT</code>的时间是2MSL, 故<code>TIME_WAIT</code>可以确保先前化身(incarnation)的老重复分组都已经在网络中消失了</p>
<blockquote>
<p>不过存在一个例外: 如果到达的SYN的序列号大于前一化身的结束序列号,源自Berkely的实现应该给当前<code>**TIME_WAIT**</code>状态的连接启动新的化身</p>
</blockquote>
</li>
</ol>
<h3 id="SCTP"><a href="#SCTP" class="headerlink" title="SCTP"></a>SCTP</h3><p><strong>连接</strong>: 类似TCP, 但是是四路握手, 主要差别在于作为SCTP整体的一部分的cookie的生成<br><strong>终止</strong>: 不允许”半关闭”</p>
<p><img src="https://ae02.alicdn.com/kf/H73231a5d00af414a8230ba256ed8ed9d1.png" alt="img"></p>
<p>连接和终止</p>
<h3 id="函数细节补充"><a href="#函数细节补充" class="headerlink" title="函数细节补充"></a>函数细节补充</h3><ul>
<li><p><code>inet_pton</code> and <code>inet_ntop</code></p>
<p> inet_addr已经被废弃了, inet_aton其实也不太好, 新的代码应该要使用<code>inet_pton</code> and <code>inet_ntop</code>, 例如如下例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sockaddr_in <span class="title">makeAddr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *addr, <span class="keyword">uint16_t</span> port)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ret</span>&#123;</span>&#125;;</span><br><span class="line">inet_pton(AF_INET, addr, &amp;ret.sin_addr.s_addr);</span><br><span class="line">  	<span class="comment">// ret.sin_addr.s_addr = inet_addr(addr); 例如用上面哪行代码代替此行</span></span><br><span class="line">  	ret.sin_family = AF_INET;</span><br><span class="line">  	ret.sin_port = htons(port);</span><br><span class="line">  	bzero(&amp;ret.sin_zero, <span class="number">8</span>)</span><br><span class="line">  	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>listen</code>的作用</p>
<p>  刚由<code>socket</code>创建的套接字, 系统默认其为主动套接字, <code>listen</code>的作用是把一个未连接的主动套接字转换为被动套接字. 第二个参数是内核为相应的socket排队的最大排队数 (incomplete connection queue: 处于<code>SYN_RCVD</code>状态)<br>     在linux 中，半连接队列的长度是由 /proc/sys/net/core/somaxconn（默认值 128） 与 backlog  tcp_max_syn_backlog 之间的最小值决定的。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/core/somaxconn 			//128</span><br></pre></td></tr></table></figure>




<h3 id="并发服务器的一个细节"><a href="#并发服务器的一个细节" class="headerlink" title="并发服务器的一个细节"></a>并发服务器的一个细节</h3><p>考虑如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"></span><br><span class="line">  listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span> = <span class="title">makeAddr</span>();</span></span><br><span class="line">  bind(listenfd, (sockaddr *)addr, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">listen</span>(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line"></span><br><span class="line">	 <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line">	 connfd = accept(listenfd, (sockaddr_in) &amp;clientAddr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">if</span>(pid = fork()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">close</span>(listenfd);</span><br><span class="line">		 <span class="comment">// do something here</span></span><br><span class="line">		 <span class="built_in">close</span>(connfd);</span><br><span class="line">		 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(connfd); <span class="comment">//注意这里</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们知道, TCP套接口字调用close会导致发送一个FIN, 然后会连接终止, 为什么这里不会呢?</strong></p>
<p>  事实上, 每个文件或socket都会有一个引用计数(引用计数在文件表项中维护), fork的时候会让计数*2, 而close让计数-1, 所以不会出现问题, 真正socket的清理和资源的释放过程要等计数为0的时候才会发生</p>
<p>  注意, 如果一直fork了也不close, 那么会耗尽所有可用的文件描述符, 导致连接一直打开着</p>
<p>  如果我们确实想要某个TCP连接上发送一个FIN, 那么我们可以改用shutdown函数.</p>
<h3 id="处理被中断的系统调用"><a href="#处理被中断的系统调用" class="headerlink" title="处理被中断的系统调用"></a>处理被中断的系统调用</h3><p>  如<code>accept</code>, 是一个慢系统调用, 多数网络支持函数都属于这个类型. 当阻塞于慢系统调用的一个进程捕获某个信号且进入相应的处理函数的时候, 该系统调用可能返回一个<code>EINTR</code>错误.(有的内核自动重启某些被中断的系统调用), <strong>不过为了便于移植</strong>, 我们必须对<code>EINTR</code>有所准备, 一个处理办法就是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) </span><br><span class="line">&#123;</span><br><span class="line">    connfd = accept(listenfd, (sockaddr_in) &amp;clientAddr, &amp;addrlen);</span><br><span class="line">	 <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>) </span><br><span class="line">     &#123;</span><br><span class="line">	 	<span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">	 	<span class="keyword">else</span> </span><br><span class="line">        	perror(<span class="string">"accept"</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 有一个函数我们不能这样处理, 就是<code>connect</code>, 如果他出了<code>EINTR</code>, 再次调用会立即返回一个错误, 我们必须用<code>select</code>函数来等待连接完成</p>
<h3 id="处理accept返回前连接终止"><a href="#处理accept返回前连接终止" class="headerlink" title="处理accept返回前连接终止"></a>处理accept返回前连接终止</h3><p>如下图的情况的时候</p>
<p><img src="https://ae02.alicdn.com/kf/H1309cb050678454d981f9f2eab34dc55W.png" alt="img"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  所有客户端和服务器都从调用socket开始, 客户端connect, 服务端bind, listen和accept, 大多数TCP都是并发的, 而大多数UDP却是迭代的</p>
<h2 id="IO复用-–-select-和-poll"><a href="#IO复用-–-select-和-poll" class="headerlink" title="IO复用 – select 和 poll"></a>IO复用 – select 和 poll</h2><ul>
<li><p>当用户处理多个 描述符, 必须使用IO复用</p>
</li>
<li><p>如果一个TCP服务器, 既要处理监听的套接字, 又要处理连接的套接字, 就要使用IO复用</p>
</li>
<li><p>如果又要TCP, 又要UDP, 就要IO复用</p>
</li>
<li><p>如果一个服务器要处理多个服务器和多个协议, 通常要IO复用(例如inetd守护进程)</p>
</li>
</ul>
<p>IO复用并非只局限于网络编程, 许多重要的应用也要采用这个技术</p>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>在了解IO复用之前需要先回顾unix的5种IO模型: 阻塞式, 非阻塞式, 复用, 信号驱动IO, 异步IO</p>
<p>其中</p>
<p><strong>非阻塞IO</strong></p>
<blockquote>
<p>【UNIX网络编程6.2】进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。</p>
</blockquote>
<p><strong>信号驱动式IO</strong></p>
<blockquote>
<p>我们也可以使用信号，让内核在描述符就绪时发送SIGIO信号通知我们。</p>
<p>这种模型的优势在于等待数据报到达期间进程不会被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。</p>
</blockquote>
<p><strong>异步I/O</strong></p>
<blockquote>
<p>异步IO是由内核通知为我们IO操作何时完成。信号驱动IO是内核通知我们何时可以启动一个IO操作</p>
<p>无论是 <strong><em>select</em></strong>  <strong><em>poll</em></strong> <strong><em>epoll</em></strong> 都是同步IO操作</p>
<p>只有 windows <strong><em>IOCP</em></strong> 真正实现了异步IO操作</p>
</blockquote>
<p>POSIX对于同步IO与异步IO的定义：</p>
<ul>
<li>同步IO ： 导致请求被进程被阻塞，直到IO操作完成</li>
<li>异步IO :    不导致请求进程阻塞  </li>
</ul>
<p>5种模型的比较</p>
<p><img src="https://ae01.alicdn.com/kf/H3623b34425e7466a98f0cbec081f6fa4v.png" alt="img"></p>
<h3 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h3><p>select系统调用的的用途是：在一段指定的时间内，监听用户感兴趣的文件描述符上可读、可写和异常等事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 一个 select demo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set rd_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock_server = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">4999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"192.168.101.165"</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line">    bind(sock_server, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="built_in">listen</span>(sock_server, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[FD_SETSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">    <span class="keyword">int</span> nSock = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">array</span>[nSock++] = sock_server;</span><br><span class="line">    <span class="keyword">int</span> maxfd = sock_server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;rd_set);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; maxfd)</span><br><span class="line">            &#123;</span><br><span class="line">                maxfd = <span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            FD_SET(<span class="built_in">array</span>[i], &amp;rd_set);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Server Listening.....\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nums = select(maxfd + <span class="number">1</span>, &amp;rd_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Readable Fd Nums:%d\n"</span>, nums);</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"error on select"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sock_server, &amp;rd_set))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_cli</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(addr_cli);</span><br><span class="line">            <span class="keyword">int</span> nfd = accept(sock_server, (struct sockaddr *)&amp;addr_cli, &amp;len);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">array</span>[nSock++] = nfd;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"New Fd Come:%d\n"</span>,nfd);</span><br><span class="line">            <span class="keyword">if</span> (--nums &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(<span class="built_in">array</span>[i], &amp;rd_set))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nread;</span><br><span class="line">                ioctl(<span class="built_in">array</span>[i], FIONREAD, &amp;nread);</span><br><span class="line">                <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close</span>(<span class="built_in">array</span>[i]);</span><br><span class="line">                    <span class="built_in">array</span>[i] = <span class="built_in">array</span>[--nSock];</span><br><span class="line">                    <span class="built_in">array</span>[nSock]=<span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Fd %d Closed\n"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">read</span>(<span class="built_in">array</span>[i], &amp;buf, nread);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Recv From Fd %d:%s\n"</span>, <span class="built_in">array</span>[i], buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>注</strong></p>
<blockquote>
<p>close() 会直接发送FIN,并不在接收对方的任何报文，如果有收到报文会回复 RST<br>shutdown(sockfd, SHUT_WR),也就是只关闭了写的时候，会发送FIN报文，通知对端（关闭了写，其实没有明确flag表明是写）。对端的协议栈也会直接回复对FIN的ACK的，同时对端的socket状态会在协议栈发送了ack后变成CLOSE_WAIT。但是对端可以继续发送报文，然后本端也可以继续接收报文.</p>
</blockquote>
<blockquote>
<p>shutdown(sockfd, SHUT_RD),就是只关闭了读的时候，是不会发送任何表明关闭了读的协议报文的。同时对端还可以发送报文，本端也会回复ack，但是本端在用系统调用recv是收不到报文的，确切的说是：先以SHUT_RD调用了shutdown，再后面recv的时候是直接返回ret=0的，不管是阻塞还是非阻塞.</p>
</blockquote>
<blockquote>
<p>shutdown(sockfd, SHUT_RDWR),也就是关闭了读写的时候，会发送FIN报文，通知对端（关闭了读写，没有明确flag表明是读写）。对端的协议栈也会直接回复对FIN的ACK的，同时对端的socket状态会在协议栈发送了ack后变成CLOSE_WAIT。但是如果对端继续发送报文，那么主动关闭的一方会直接回RST的。</p>
</blockquote>
<blockquote>
<p>close关闭其实是减少计数，假如有dup过，那么并不会完全关闭套接字。<br>shutdown会直接根据参数对socket执行操作，而不管是不是dup过。</p>
</blockquote>
<h4 id="pselect函数"><a href="#pselect函数" class="headerlink" title="pselect函数"></a>pselect函数</h4><p>POSIX发明的, 有许多的unix变种支持，暂不详细讨论</p>
<ul>
<li>用timespec结构而不是timeval</li>
<li>增加一个指向信号的掩码的指针, 该参数允许程先序禁止递交某些信号, 再测试它们(这些信号)的handler设置的全局变量, 然后调用<code>pselect</code> (也就是暂时更换’信号掩码’, 例如解除某个信号的阻塞)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set* readset,fd_set* writeset, fd_set* exceptset, <span class="keyword">const</span> struct timespec* timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* sigmask)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h3><p>poll和select类似, 只不过在处理流函数的时候能够提供额外的信息。</p>
<table>
<thead>
<tr>
<th>常值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>POLLIN</td>
<td>普通或者优先级数据可读</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td>普通数据可读</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td>优先级带数据可读</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>高优先级数据可读</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>普通数据可写</td>
</tr>
<tr>
<td>POLLWRNORM</td>
<td>普通数据可写</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td>优先级带数据可写</td>
</tr>
<tr>
<td>POLLERR</td>
<td>发生错误</td>
</tr>
<tr>
<td>POLLHUP</td>
<td>发生挂起</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>描述符不是一个打开的文件</td>
</tr>
</tbody></table>
<p>就TCP和UDP套接字而言，以下条件引起poll返回特定的revent,但不幸的是，POSIX在poll的定义中留了许多空洞。</p>
<ul>
<li>所有正规TCP数据和所有UDP数据被认为普通数据</li>
<li>当TCP连接读半部关闭，譬如收到来自对端的FIN，也被认为是普通数据，随后的读操作将返回0.</li>
<li>TCP的连接存在错误既可以认为是普通数据，也可以认为是错误(<strong>POLLERR</strong>),无论哪种情况随后的读操作将返回-1，并把<strong>errno</strong>设置成合适的值。这可用于处理诸如接收到<strong>RST</strong>或发生超时等条件</li>
<li>在监听套接字上有新的连接可用可认为是普通数据，也可认为是优先级数据，大多数视之为普通数据。</li>
<li>非阻塞 <strong>connect</strong>的完成被认为是使相应套接字可写。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENTSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> listenfd = <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == (listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> reuseaddr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr, <span class="keyword">sizeof</span>(reuseaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"setsockopt: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = PF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">8008</span>);</span><br><span class="line">    inet_pton(PF_INET, <span class="string">"0.0.0.0"</span>, &amp;servaddr.sin_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(listenfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"bind: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">listen</span>(listenfd, <span class="number">5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"listen: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnoblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldopt = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> newopt = oldopt | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, newopt);</span><br><span class="line">    <span class="keyword">return</span> oldopt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfds</span>[<span class="title">CLIENTSIZE</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = createSocket();</span><br><span class="line"></span><br><span class="line">    pfds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    pfds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">    pfds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> connnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = poll(pfds,connnum + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">// -1 will block</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"Error on poll\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connnum + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pfds[i].revents &amp; POLLHUP) || (pfds[i].revents &amp; POLLERR))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = pfds[i].fd;</span><br><span class="line">                <span class="built_in">close</span>(fd);</span><br><span class="line">                pfds[i--] = pfds[connnum--];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"delete connection: %d\n"</span>, fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pfds[i].fd == listenfd) &amp;&amp; (pfds[i].revents &amp; POLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                struct sockaddr_in client;</span><br><span class="line">                <span class="keyword">socklen_t</span> lenaddr = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">int</span> conn = <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == (conn = accept(listenfd, (struct sockaddr*)&amp;client, &amp;lenaddr)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"accept: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"New Connection %d from %s:%d\n"</span>, conn, inet_ntoa(client.sin_addr), client.sin_port);</span><br><span class="line">                connnum++;</span><br><span class="line">                setnoblock(conn);</span><br><span class="line"></span><br><span class="line">                pfds[connnum].fd = conn;</span><br><span class="line">                pfds[connnum].events = POLLIN | POLLHUP | POLLERR;</span><br><span class="line">                pfds[connnum].revents = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有可读数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pfds[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">int</span> lenrecv = recv(pfds[i].fd, buf, BUFSIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (lenrecv &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pfds[i].events &amp;= (~POLLIN);</span><br><span class="line">                    pfds[i].events |= POLLOUT;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Recv : %s\n"</span>,buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (lenrecv == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"------- client %d exit--------\n"</span>, pfds[i].fd);</span><br><span class="line">                    <span class="built_in">close</span>(pfds[i].fd);</span><br><span class="line">                    pfds[i--] = pfds[connnum--];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"recv: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可写数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pfds[i].revents &amp; POLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (send(pfds[i].fd,buf,<span class="built_in">strlen</span>(buf), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ECONNRESET == errno)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"send: %d, %s\n"</span>, errno, strerror(errno));</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                pfds[i].events &amp;= (~POLLOUT);</span><br><span class="line">                pfds[i].events |= POLLIN;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h3><p>有很多方式来设置和影响套接字选项, 例如<code>getsockopt</code>, <code>setsockopt</code>, <code>fcntl</code>, <code>ioctl</code>,关于传输层的套接字选项, 请自行google或参考有关文档和书籍</p>
<h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p><img src="https://ae02.alicdn.com/kf/Ha628340ad172485e8d9ae24c2c7aff5dS.png" alt="img"></p>
<p>UDP编程模型</p>
<p>创建socket的时候要把<strong>SOCK_STREAM</strong>改成<strong>SOCK_DGRAM</strong></p>
<h3 id="recvfrom-和-sendto函数"><a href="#recvfrom-和-sendto函数" class="headerlink" title="recvfrom 和 sendto函数"></a>recvfrom 和 sendto函数</h3><p>类似与标准的read和write, 不过需要3个额外的参数: flags, from, addrlen, flags参数先不说, 暂时把他当成0, 后续会解释; from和addrlen参数和accept的最后两个参数类似</p>
<p>-<strong>注</strong>: 如果from是一个空指针, 那么addrlen也一样要是一个空指针, 表示我们不关心地址.</p>
<blockquote>
<p>`<strong>recvfrom</strong>和<strong>sendto</strong>都可以用于TCP, 尽管通常没有理由那么做*</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dg_echo</span><span class="params">(<span class="keyword">int</span> sockfd, SA* pcliaddr, <span class="keyword">socklen_t</span> clilen)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="keyword">char</span> mesg[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// `len` should be initialized to the size of the*</span></span><br><span class="line">		len = clilen;</span><br><span class="line">		n = recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, pcliaddr, &amp;len);</span><br><span class="line">    	sendto(sockfd, mesg, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> sockfd;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">  	sockfd  = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"> 	servaddr = makeAddr(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">  	bind(sockfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">  	dg_echo(sockfd, (SA*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码虽简单, 但是有几个细节需要注意</p>
<ul>
<li><p>首先, 函数永不终止, 因为UDP是一个无连接的协议, 它没有像TCP中的EOF之类的东西</p>
</li>
<li><p>这是一个迭代服务器, 不像TCP服务器那样可以提供一个并发的服务器, 其中没有fork的调用,因此单个进程就得处理所有客户</p>
</li>
<li><p>对于本套接字, UDP层有排队发生, 事实上每个UDPsocket都有一个接收缓存区</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/13/TCP%E4%B8%AD%E7%9A%84Sequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/13/TCP%E4%B8%AD%E7%9A%84Sequence/" itemprop="url">
                  TCP 中的Sequence Number
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-13T21:41:57+08:00">
                2020-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://ae02.alicdn.com/kf/Hfe46670e16b74f51b00fa8c96b83ad52i.png" alt="img"></p>
<p>我们关注的就是<strong>序号</strong> 和 <strong>确认号</strong>，这二者也是 TCP 实现可靠传输的方式。</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>当某个主机开启一个TCP会话时，他的初始序列号是随机的，可能是0和4,294,967,295之间的任意值，然而，像Wireshark这种工具，通常显示的都是相对序列号/确认号，而不是实际序列号/确认号，相对序列号/确认号是和TCP会话的初始序列号相关联的。这是很方便的，因为比起真实序列号/确认号，跟踪更小的相对序列号/确认号会相对容易一些，通过序号的方式保存数据的顺序，接收端接受到之后进行重新排列。</p>
<p>因此，对于SEQ和ACK：<br>SEQ 代表：<strong>发送的这个包中第一个字节（如果有payload的话）的序号</strong><br>ACK 代表：<strong>已成功接受序列号到 ack-1 的数据，期望接收的下一个字节的序号为 ack</strong></p>
<p>举例说明：</p>
<blockquote>
<p>我已经发送了前100字节的数据，那么我下一个发送的包（如果发送窗口还有空间）的SEQ就是101，比如要发送10字节的数据，那么下一个包中的数据的字节编号就是 101 - 110. 之后如果继续发送的话，序号就是从111开始。</p>
</blockquote>
<blockquote>
<p>如果接收端接到了这个10字节的包的话，便会返回一个 ACK 为 111 的包，表示前面110个字节已经成功接收。</p>
</blockquote>
<h2 id="为什么SYN和FIN会消耗一个序列号"><a href="#为什么SYN和FIN会消耗一个序列号" class="headerlink" title="为什么SYN和FIN会消耗一个序列号"></a>为什么SYN和FIN会消耗一个序列号</h2><p>原因是 SYN 和 FIN 信号都是需要 acknowledgement 的，也就是你必须回复这个信号，如果它不占有一个字节（序列号）的话，要如何判断你是回复这个信号还是回复这个信号之前的包呢？</p>
<p>例如：如果 FIN 信号不占用一个字节（序列号），回复 FIN 的 ack 包就可能被误认为是回复之前的数据包被重新发送了一次，第二次挥手无法完成，连接也就无法正常关闭了。</p>
<p>从TCP的可靠传输角度来说，TCP是靠<strong>确认</strong>这个步骤来做到的，也就是Ack,用Ack来表示我这边已经收到了你发送的东西，包括数据和命令两部分，在可靠传输中用于建立和释放通道的就是命令。通道的建立需要双方进行协商，一方开始一个连接告知对方自己的数据，另一方则要对其进行确认，确认就是通过确认号来做。</p>
<p>而除了Syn和Fin的其他标志位，则不需要消耗一个序列号。首先Ack是为确认而生，如果给它一个序列号，则意味着还要对其自己进行确认，这就是一个死循环了。Rst标志位在使用的使用，也就表示TCP的可靠连接结束了，自然没有必要再去消耗序列号，进行确认。</p>
<p>总之TCP的整个过程，我们需要确认Syn和Fin两个命令。</p>
<h2 id="为什么SYN和ACK的初始值（ISN-initialization-sequence-number）是一个随机值"><a href="#为什么SYN和ACK的初始值（ISN-initialization-sequence-number）是一个随机值" class="headerlink" title="为什么SYN和ACK的初始值（ISN initialization sequence number）是一个随机值"></a>为什么SYN和ACK的初始值（ISN initialization sequence number）是一个随机值</h2><blockquote>
<p>ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<strong>[<em>RFC793</em>]</strong>(<em><a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc793</a></em>)<strong>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL –* *[<em>Wikipedia语条</em>]</strong>(<em><a href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime</a></em>)<em>*），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</em></p>
</blockquote>
<h2 id="什么是TCP-segment-of-a-reassembled-PDU"><a href="#什么是TCP-segment-of-a-reassembled-PDU" class="headerlink" title="什么是TCP segment of a reassembled PDU"></a>什么是TCP segment of a reassembled PDU</h2><p><img src="https://ae01.alicdn.com/kf/H576e3f9ae19846eda83e94a5391daeacU.png" alt="img"></p>
<p>如图所示，在抓包的时候，经常会看到[TCP segment of a reassembled PDU ] 字样的包，这个代表数据在传输层被分包了。也就是代表包大小大于MTU，此处放一下MTU与MSS区别：</p>
<blockquote>
<p>MTU（Maximum Transmission Unit）最大传输单元，在TCP/IP协议族中，指的是IP数据报能经过一个物理网络的最大报文长度，其中包括了IP首部(从20个字节到60个字节不等)，一般以太网的MTU设为1500字节，加上以太帧首部的长度14字节，也就是一个以太帧不会超过1500+14 = 1514字节。*MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，更小的 MTU 意味着更低的网络延迟。每一个物理设备都有自己的 MTU，两个主机之间的 MTU 依赖于底层的网络能力，它由整个链路上 MTU 最小的物理设备决定。</p>
</blockquote>
<blockquote>
<p>MSS（Maximum Segment Size，最大报文段大小，指的是TCP报文（一种IP协议的上层协议）的最大数据报长度，其中不包括TCP首部长度。MSS由TCP链接的过程中由双方协商得出，其中SYN字段中的选项部分包括了这个信息。如果MSS+TCP首部+IP首部大于MTU，那么IP报文就会存在分片，如果小于，那么就可以不需要分片正常发送。</p>
</blockquote>
<p>因此，出现这种现象的原因就是你调用一次send的时候，send的数据比 MSS 还要打，因此就被协议栈进行了分包。</p>
<p>顺便说一下，IP数据包的分片是通过flag字段和offset字段共同完成的。</p>
<p>从图中可以看到，第6个和第5个包是同一个TCP报文被分成了两个包。如果我们点开看的话，可以看到两个报文的ACK序号都一样，并且这些报文的Sequence Number都不一样，并且后一个Sequence Number为前一个Sequence Number加上前一个报文大小再加上1 。这也是判断reassembled 的方式。</p>
<p>点开第6个包，可以看到它将5和6的数据整合起来了。</p>
<h2 id="为什么TCP要进行分片呢？明明IP协议会进行分片的？"><a href="#为什么TCP要进行分片呢？明明IP协议会进行分片的？" class="headerlink" title="为什么TCP要进行分片呢？明明IP协议会进行分片的？"></a>为什么TCP要进行分片呢？明明IP协议会进行分片的？</h2><ul>
<li>IP 协议会分片传输过大的数据包（Packet）避免物理设备的限制；</li>
<li>TCP 协议会分段传输过大的数据段（Segment）保证传输的性能；</li>
</ul>
<p>路径最大传输单元发现（Path MTU Discovery，PMTUD）是用来确定两个主机传输路径 MTU 的机制，它的工作原理如下：</p>
<ol>
<li>向目的主机发送 IP 头中 DF 控制位为 1 的数据包，DF 是不分片（Don’t Fragment，DF）的缩写；</li>
<li>路径上的网络设备根据数据包的大小和自己的 MTU 做出不同的决定：<ol>
<li>如果数据包大于设备的 MTU，就会丢弃数据包并发回一个包含该设备 MTU 的 ICMP 消息；</li>
<li>如果数据包小于设备的 MTU，就会继续向目的主机传递数据包；</li>
</ol>
</li>
<li>源主机收到 ICMP 消息后，会不断使用新的 MTU 发送 IP 数据包，直到 IP 数据包达到目的主机；</li>
</ol>
<blockquote>
<p>ICMP 是互联网控制消息协议（Internet Control Message Protocol，ICMP），它能在 IP 主机之间传递控制消息。</p>
</blockquote>
<p>以太网对数据帧的限制一般都是 1500 字节，在一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输。</p>
<p>IP 协议数据分片对传输层协议是透明的，假设我们使用 UDP 协议传输 2000 字节的数据，加上 UDP 8 字节的协议头，IP 协议需要传输 2008 字节的数据。如下图所示，当 IP 协议发现待传输的数据大于 1480 字节，就会将数据分成下面的两个数据包：</p>
<p><img src="https://img.draveness.me/2020-02-12-15814868931890-udp-ip-packet.png" alt="img"></p>
<p><strong>分片传输的 UDP 数据</strong></p>
<ol>
<li>20 字节 IP 协议头 + 8 字节 UDP 协议头 + 1472 字节数据；</li>
<li>20 字节 IP 协议头 + 528 字节数据；</li>
</ol>
<p>数据的接收方在收到数据包时会对分片的数据进行重组，不过因为第二个数据包中不包含 UDP 协议的相关信息，一旦发生丢包，整个 UDP 数据报就无法重新拼装。如果 UDP 数据报需要传输的数据过多，那么 IP 协议就会大量分片，增加了不稳定性。</p>
<p>如果 IP 协议没有数据包大小的限制，那么上层可以以消息为单位传输数据，自然就不存在分片和组装的需求，不过因为物理设备的 MTU 限制，想要保证数据传输的可靠性和稳定性还需要传输层的配合。</p>
<h4 id="最大分段大小"><a href="#最大分段大小" class="headerlink" title="最大分段大小"></a>最大分段大小</h4><p>TCP 协议是面向字节流的协议，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机发送，应用层交给 TCP 协议发送的数据可能会被拆分到多个数据段中。</p>
<p>TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 连接的 MSS 是 MTU - 40 字节，即 1460 字节；不过如果通信双方没有指定 MSS 的话，在默认情况下 MSS 的大小是 536 字节。</p>
<p>IP 协议的 MTU 是物理设备上的限制，它限制了路径能够发送数据包的上限，而 TCP 协议的 MSS 是操作系统内核层面的限制，通信双方会在三次握手时确定这次连接的 MSS。一旦确定了 MSS，TCP 协议就会对应用层交给 TCP 协议发送的数据进行拆分，构成多个数据段。</p>
<p>需要注意的是，IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包（Package）为单位组织数据，而 TCP 协议以数据段（Segment）为单位组织数据。</p>
<p>如下图所示，如果 TCP 连接的 MSS 是 1460 字节，应用层想要通过 TCP 协议传输 2000 字节的数据，那么 TCP 协议会根据 MSS 将 2000 字节的数据拆分到两个数据段中：</p>
<p><img src="https://img.draveness.me/2020-02-12-15814868931896-tcp-ip-packet.png" alt="tcp-ip-packet"></p>
<p><strong>图 4 - 分段传输的 TCP 数据</strong></p>
<ul>
<li>20 字节 IP 头 + 20 字节 TCP 头 + 1460 字节数据；</li>
<li>20 字节 IP 头 + 20 字节 TCP 头 + 540 字节数据；</li>
</ul>
<p>从应用层的角度来看，两个数据段中 2000 字节的数据构成了发送方想要发送的消息，但是 TCP 协议是面向字节流的，向协议写入的数据会以流的形式传递到对端。</p>
<p>TCP 协议为了保证可靠性，会通过 IP 协议的 MTU 计算出 MSS 并根据 MSS 分段避免 IP 协议对数据包进行分片。因为 IP 协议对数据包的分片对上层是透明的，如果协议不根据 MTU 做一些限制，那么 IP 协议的分片会导致部分数据包失去传输层协议头，一旦数据包发生丢失就只能丢弃全部数据。</p>
<p>我们可以通过一个例子分析 MSS 存在的必要性。如下图所示，假设 TCP 协议中不存在 MSS 的概念，因为每个数据段的大小没有上限，当 TCP 协议交给 IP 层发送两个 1600 字节（包括 IP 和 TCP 协议头）的数据包时，由于物理设备的限制，IP 协议的路径 MTU 为 1500 字节，所以 IP 协议会对数据包分片：</p>
<p><img src="https://img.draveness.me/2020-02-12-15814868931902-tcp-ip-packet-with-ip-fragmentation.png" alt="tcp-ip-packet-with-ip-fragmentation"></p>
<p><strong>图 4 - 分片传输的 TCP 数据</strong></p>
<p>四个数据包中只有两个会包含 TCP 协议头，即控制位、序列号等信息，剩下的两个数据包中不包含任何信息。当 IP 协议传输数据丢包时，TCP 协议的接收方没有办法对数据包进行重组，所以整个 TCP 数据段都需要重传，带来了更多额外的重传和重组开销。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据拆分的根本原因说到底还是物理设备的限制，不过每一层协议都受限于下一层协议做出的决定，并依赖下层协议重新决定设计和实现的方法。虽然 TCP/IP 协议在传输数据时都需要对数据进行拆分，但是它们做出拆分数据的设计基于不同的上下文，也有着不同的目的，我们在这里总结一下两个网络协议做出类似决定的原因：</p>
<ul>
<li>IP 协议拆分数据是因为物理设备的限制，一次能够传输的数据由路径上 MTU 最小的设备决定，一旦 IP 协议传输的数据包超过 MTU 的限制就会发生丢包，所以我们需要通过路径 MTU 发现获取传输路径上的 MTU 限制；</li>
<li>TCP 协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头，如果数据段大小超过了 IP 协议的 MTU 限制， 就会带来更多额外的重传和重组开销，影响性能。</li>
</ul>
<p>通过本文的分析，相信各位读者不仅了解了为什么 TCP/IP 协议会拆分数据，也了解了为什么 UDP 协议的数据报不应该超过 MTU - 28 字节，一旦超过该限制，IP 协议的分片机制会增加 UDP 数据报无法重组的可能性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url">
                  计算机网络基础知识总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-11T10:30:57+08:00">
                2020-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="阅读目录"><a href="#阅读目录" class="headerlink" title="阅读目录"></a>阅读目录</h3><ol>
<li><p>网络层次划分</p>
</li>
<li><p>OSI七层网络模型</p>
</li>
<li><p>IP地址</p>
</li>
<li><p>子网掩码及网络划分</p>
</li>
<li><p>ARP/RARP协议</p>
</li>
<li><p>路由选择协</p>
</li>
<li><p>TCP/IP协议</p>
</li>
<li><p>UDP协议　</p>
</li>
<li><p>DNS协议</p>
</li>
<li><p>NAT协议</p>
</li>
<li><p>DHCP协议</p>
</li>
<li><p>HTTP协议</p>
</li>
<li><p>一个举例</p>
</li>
</ol>
<p>计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。一个很形象地比喻就是我们的语言，我们大天朝地广人多，地方性语言也非常丰富，而且方言之间差距巨大。A地区的方言可能B地区的人根本无法接受，所以我们要为全国人名进行沟通建立一个语言标准，这就是我们的普通话的作用。同样，放眼全球，我们与外国友人沟通的标准语言是英语，所以我们才要苦逼的学习英语。</p>
<p>计算机网络协议同我们的语言一样，多种多样。而ARPA公司与1977年到1979年推出了一种名为ARPANET的网络协议受到了广泛的热捧，其中最主要的原因就是它推出了人尽皆知的TCP/IP标准网络协议。</p>
<h3 id="1、网络层次划分"><a href="#1、网络层次划分" class="headerlink" title="1、网络层次划分"></a>1、网络层次划分</h3><p>为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。</p>
<p>除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议。</p>
<h3 id="2、OSI七层网络模型"><a href="#2、OSI七层网络模型" class="headerlink" title="2、OSI七层网络模型"></a>2、OSI七层网络模型</h3><p>TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。</p>
<p><img src="https://ae01.alicdn.com/kf/Hd3267d5c6e93432d90b39abc5f939156Z.jpg" alt="img"></p>
<p><strong>1）物理层（Physical Layer）</strong></p>
<p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。<strong>该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</strong>物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。</p>
<p><strong>2）数据链路层（Data Link Layer）</strong></p>
<p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p>
<p>有关数据链路层的重要知识点：</p>
<p><strong>1&gt; 数据链路层为网络层提供可靠的数据传输；</strong></p>
<p><strong>2&gt; 基本数据单位为帧；</strong></p>
<p><strong>3&gt; 主要的协议：以太网协议；</strong></p>
<p><strong>4&gt; 两个重要设备名称：网桥和交换机。</strong></p>
<p><strong>3）网络层（Network Layer）</strong></p>
<p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。</p>
<p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p>
<p><strong>1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</strong></p>
<p><strong>2&gt; 基本数据单位为IP数据报；</strong></p>
<p><strong>3&gt; 包含的主要协议：</strong></p>
<p><strong>IP协议（Internet Protocol，因特网互联协议）;</strong></p>
<p><strong>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</strong></p>
<p><strong>ARP协议（Address Resolution Protocol，地址解析协议）;</strong></p>
<p><strong>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</strong></p>
<p><strong>4&gt; 重要的设备：路由器。</strong></p>
<p><strong>4）传输层（Transport Layer）</strong></p>
<p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p>
<p>传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。</p>
<p>网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</p>
<p>有关网络层的重点：</p>
<p><strong>1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</strong></p>
<p><strong>2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；</strong></p>
<p><strong>3&gt; 重要设备：网关。</strong></p>
<p><strong>5）会话层</strong></p>
<p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<p><strong>6）表示层</strong></p>
<p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<p><strong>7）应用层</strong></p>
<p>为操作系统或网络应用程序提供访问网络服务的接口。</p>
<p>会话层、表示层和应用层重点：</p>
<p><strong>1&gt; 数据传输基本单位为报文；</strong></p>
<p><strong>2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</strong></p>
<h3 id="3、IP地址"><a href="#3、IP地址" class="headerlink" title="3、IP地址"></a>3、IP地址</h3><p><strong>1）网络地址</strong></p>
<p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p>
<p><strong>2）广播地址</strong></p>
<p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p>
<p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p>
<p><strong>3）组播地址</strong></p>
<p>D类地址就是组播地址。</p>
<p>先回忆下A，B，C，D类地址吧：</p>
<p>A类地址以00开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p>
<p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p>
<p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p>
<p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p>
<p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p>
<p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p>
<p><strong>4）255.255.255.255</strong></p>
<p>该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p>
<p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p>
<p><strong>5）0.0.0.0</strong></p>
<p>常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p>
<p><strong>6）回环地址</strong></p>
<p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p>
<p><strong>7）A、B、C类私有地址</strong></p>
<p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p>
<p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p>
<p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p>
<p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p>
<h3 id="4、子网掩码及网络划分"><a href="#4、子网掩码及网络划分" class="headerlink" title="4、子网掩码及网络划分"></a>4、子网掩码及网络划分</h3><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p>
<p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p>
<p><strong>什么是子网掩码？</strong></p>
<p>子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</p>
<p><strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即“ 0”地址和广播地址，它们是指主机地址或网络地址全为“ 0”或“ 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p>
<p><strong>子网掩码的计算：</strong></p>
<p>对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。</p>
<p>下面总结一下有关子网掩码和网络划分常见的面试考题：</p>
<p><strong>1）利用子网数来计算</strong></p>
<p>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p>
<p>(1) 将子网数目转化为二进制来表示;</p>
<p>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p>
<p>(2) 取得该二进制的位数，为N；</p>
<p>该二进制为五位数，N = 5</p>
<p>(3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。</p>
<p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0</p>
<p><strong>2）利用主机数来计算</strong></p>
<p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p>
<p>(1) 将主机数目转化为二进制来表示；</p>
<p>700=1010111100；</p>
<p>(2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位；</p>
<p>该二进制为十位数，N=10；</p>
<p>(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p>
<p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</p>
<p><strong>3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和**</strong>计算子网掩码。这也可按上述原则进行计算。**</p>
<p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p>
<p>10＋1＋1＋1＝13</p>
<p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网**</strong>络地址和广播地址。**</p>
<p>因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。</p>
<p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p>
<h3 id="5、ARP-RARP协议"><a href="#5、ARP-RARP协议" class="headerlink" title="5、ARP/RARP协议"></a>5、ARP/RARP协议</h3><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</strong>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。<strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p>
<p>ARP工作流程举例：</p>
<p>主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；</p>
<p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；</p>
<p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p>
<p>（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。</p>
<p>（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</p>
<p>（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p>
<p>（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。</p>
<p>（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p>
<p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong>，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p>
<p>RARP协议工作流程：</p>
<p>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p>
<p>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p>
<p>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p>
<p>（4）如果不存在，RARP服务器对此不做任何的响应；</p>
<p>（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p>
<h3 id="6、路由选择协议"><a href="#6、路由选择协议" class="headerlink" title="6、路由选择协议"></a>6、路由选择协议</h3><p>常见的路由选择协议有：RIP协议、OSPF协议。</p>
<p><strong>RIP**</strong>协议** ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p>
<p><strong>OSPF**</strong>协议** ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p>
<h3 id="7、TCP-IP协议"><a href="#7、TCP-IP协议" class="headerlink" title="7、TCP/IP协议"></a>7、TCP/IP协议</h3><p><strong>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p>
<p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p>
<p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p>
<p><strong>TCP报文首部格式：</strong></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>TCP协议的三次握手和四次挥手：</strong></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><strong>注：seq</strong>:”sequance”序列号；<strong>ack</strong>:”acknowledge”确认号；<strong>SYN</strong>:”synchronize”请求同步标志；<strong>；ACK</strong>:”acknowledge”确认标志”<strong>；**</strong>FIN**：”Finally”结束标志。</p>
<p><strong>TCP连接建立过程：</strong>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p>
<p><strong>TCP连接断开过程：</strong>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p><strong>为什么要三次挥手？</strong></p>
<p>在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！</p>
<p><strong>为什么要四次挥手？</strong></p>
<p>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p>
<p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p>
<h3 id="8、UDP协议"><a href="#8、UDP协议" class="headerlink" title="8、UDP协议　"></a>8、UDP协议　</h3><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。**</strong>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。**</p>
<p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p>
<p>每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：</p>
<p>（1）源端口号；</p>
<p>（2）目标端口号；</p>
<p>（3）数据报长度；</p>
<p>（4）校验值。</p>
<p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p>
<p><strong>TCP</strong> <strong>与</strong> <strong>UDP</strong> <strong>的区别：</strong>TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</p>
<h3 id="9、DNS协议"><a href="#9、DNS协议" class="headerlink" title="9、DNS协议"></a>9、DNS协议</h3><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，<strong>可以简单地理解为将URL转换为IP地址</strong>。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。</p>
<h3 id="10、NAT协议"><a href="#10、NAT协议" class="headerlink" title="10、NAT协议"></a>10、NAT协议</h3><p>NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p>
<h3 id="11、DHCP协议"><a href="#11、DHCP协议" class="headerlink" title="11、DHCP协议"></a>11、DHCP协议</h3><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h3 id="12、HTTP协议"><a href="#12、HTTP协议" class="headerlink" title="12、HTTP协议"></a>12、HTTP协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p>
<p><strong>HTTP</strong> <strong>协议包括哪些请求？</strong></p>
<p>GET：请求读取由URL所标志的信息。</p>
<p>POST：给服务器添加信息（如注释）。</p>
<p>PUT：在给定的URL下存储一个文档。</p>
<p>DELETE：删除给定的URL所标志的资源。</p>
<p><strong>HTTP</strong> <strong>中，</strong> <strong>POST</strong> <strong>与</strong> <strong>GET</strong> <strong>的区别</strong></p>
<p>1）Get是从服务器上获取数据，Post是向服务器传送数据。</p>
<p>2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</p>
<p>3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</p>
<p>4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>
<p>I. 所谓 <strong>安全的</strong> 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p>
<p>II. <strong>幂等</strong> 的意味着对同一URL的多个请求应该返回同样的结果。</p>
<h3 id="13、一个举例"><a href="#13、一个举例" class="headerlink" title="13、一个举例"></a>13、一个举例</h3><p><strong>在浏览器中输入</strong> <strong><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> <strong>后执行的全部过程</strong></p>
<p>现在假设如果我们在客户端（客户端）浏览器中输入<a href="http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：">http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</a></p>
<p>1）客户端浏览器通过DNS解析到<a href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。" target="_blank" rel="noopener">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
<p>2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
<p>3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p>4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/std_enable_if/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/06/07/std_enable_if/" itemprop="url">
                  std::enable_if
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-07T20:35:57+08:00">
                2020-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>SFINAE是英文Substitution failure is not an error的缩写，意思是匹配失败不是错误。这句话什么意思呢？当调用模板函数时编译器会根据传入参数推导最合适的模板函数，在这个推导过程中如果某一个或者某几个模板函数推导出来是编译无法通过的，只要有一个可以正确推导出来，那么那几个推导得到的可能产生编译错误的模板函数并不会引发编译错误</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">typename</span> T::foo)</span> </span>&#123;&#125; <span class="comment">// Definition #1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;&#125;               <span class="comment">// Definition #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f&lt;Test&gt;(<span class="number">10</span>); <span class="comment">// Call #1.</span></span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);  <span class="comment">// Call #2. Without error (even though there is no int::foo) thanks to SFINAE.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是wiki上SFINAE的一个经典示例，注释已经解释的相当明白，由于推导模板函数过程中可以找到一个正确的版本，所以即时int::foo是一个语法错误，但是编译器也不会报错。这就是SFINAE要义。在C++11中，标准确立了这种编译的行为，而不像C++98未明确定义它的行为。通过std::enable_if和SFINAE的共同使用，会产生很多很奇妙的实现，STL库中大量的应用了这种组合，下面我们来看看他们组合一起是如何工作的。</p>
</blockquote>
<blockquote>
<p>一个普通版本的模板类定义，一个偏特化版本的模板类定义。它在第一个模板参数为false的时候并不会定义type，只有在第一模板参数为true的时候才会定义type。看一下下面的模板实例化代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">true</span>, <span class="keyword">int</span>&gt;::type t; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">true</span>&gt;::type;        <span class="comment">//可以通过编译，没有实际用处，推导的模板是偏特化版本，第一模板参数是true，第二模板参数是通常版本中定义的默认类型即void</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">false</span>&gt;::type;       <span class="comment">//无法通过编译，type类型没有定义</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">false</span>, <span class="keyword">int</span>&gt;::type t2; <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以看到，通过typename std::enable_if<bool>::type这样传入一个bool值，就能推导出这个type是不是未定义的。那么这种用法有什么用途呢？结合上面的SFINAE来看代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_trivial&lt;T&gt;::value&gt;::<span class="function">type <span class="title">SFINAE_test</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"T is trival"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;!<span class="built_in">std</span>::is_trivial&lt;T&gt;::value&gt;::<span class="function">type <span class="title">SFINAE_test</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"T is none trival"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">SFINAE_test(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"123"</span>));</span><br><span class="line">SFINAE_test(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这两个函数如果是普通函数的话，根据重载的规则是不会通过编译的。即便是模板函数，如果这两个函数都能推导出正确的结果，也会产生重载二义性问题，但是正因为std::enable_if的运用使这两个函数的返回值在同一个函数调用的推导过程中只有一个合法，遵循SFINAE原则，则可以顺利通过编译。</p>
</blockquote>
<blockquote>
<p>当第一个函数调用进行模板函数推导的时候，第一个版本的模板函数std::is_trivial<T>::value为false，继而std::enable_if&lt;std::is_trivial<T>::value&gt;::type这个类型未定义，不能正确推导，编译器区寻找下一个可能的实现，所以接下来找到第二个模板函数，!std::is_trivial<T>::value的值是true，继而std::enable_if&lt;std::is_trivial<T>::value&gt;::type是void类型，推导成功。这时候SFINAE_test(std::string(“123”));调用有了唯一确定的推导，即第二个模板函数，所以程序打印T is none trival。与此相似的过程，第二个函数调用打印出T is trival。<br>这样写的好处是什么？这个例子中可以认为我们利用SFINAE特性实现了通过不同返回值，相同函数参数进行了函数重载，这样代码看起来更统一一些。还有一些其他应用std::enable_if的方式，比如在模板参数列表里，在函数参数列表里，都是利用SFINAE特性来实现某一些函数的选择推导。来看一下cpprefrence上的例子代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> detail &#123; <span class="class"><span class="keyword">struct</span> <span class="title">inplace_t</span>&#123;</span>&#125;; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">void</span>* p, detail::<span class="keyword">inplace_t</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// enabled via the return type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;<span class="built_in">std</span>::is_trivially_constructible&lt;T,Args&amp;&amp;...&gt;::value&gt;::type </span><br><span class="line">    construct(T* t,Args&amp;&amp;... args) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing trivially constructible T\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// enabled via a parameter</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span>* <span class="title">t</span>, </span></span><br><span class="line"><span class="class">             <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;<span class="built_in">std</span>::is_trivially_destructible&lt;T&gt;::value&gt;::type* = <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroying trivially destructible T\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// enabled via a template parameter</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">         <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">             !<span class="built_in">std</span>::is_trivially_destructible&lt;T&gt;&#123;&#125; &amp;&amp;</span><br><span class="line">             (<span class="built_in">std</span>::is_class&lt;T&gt;&#123;&#125; || <span class="built_in">std</span>::is_union&lt;T&gt;&#123;&#125;),</span><br><span class="line">            <span class="keyword">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">void</span> destroy(T* t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroying non-trivially destructible T\n"</span>;</span><br><span class="line">    t-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">aligned_union_t</span>&lt;<span class="number">0</span>,<span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; u;</span><br><span class="line"> </span><br><span class="line">    construct(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;u));</span><br><span class="line">    destroy(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;u));</span><br><span class="line"> </span><br><span class="line">    construct(<span class="keyword">reinterpret_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt;(&amp;u),<span class="string">"Hello"</span>);</span><br><span class="line">    destroy(<span class="keyword">reinterpret_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt;(&amp;u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/std_string_wstring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/27/std_string_wstring/" itemprop="url">
                  std_string_wstring
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-27T20:51:33+08:00">
                2020-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="std-string-std-wstring"><a href="#std-string-std-wstring" class="headerlink" title="std::string std::wstring"></a>std::string std::wstring</h3><p><strong>std::string 与 std::wstring 转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ws2s</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> &amp;ws)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> curLocale = setlocale(LC_ALL, <span class="literal">NULL</span>);</span><br><span class="line">    setlocale(LC_ALL, <span class="string">"chs"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span>* _source = ws.c_str();</span><br><span class="line">    <span class="keyword">size_t</span> _dsize = <span class="number">2</span> * ws.size() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* _dest = <span class="keyword">new</span> <span class="keyword">char</span>[_dsize];</span><br><span class="line">    <span class="built_in">memset</span>(_dest, <span class="number">0x0</span>, _dsize);</span><br><span class="line">    wcstombs_s(&amp;i, _dest, _dsize, _source, _dsize);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = _dest;</span><br><span class="line">    <span class="keyword">delete</span>[] _dest;</span><br><span class="line">    setlocale(LC_ALL, curLocale.c_str());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">s2ws</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> curLocale = setlocale(LC_ALL, <span class="literal">NULL</span>);</span><br><span class="line">    setlocale(LC_ALL, <span class="string">"chs"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* _source = s.c_str();</span><br><span class="line">    <span class="keyword">size_t</span> _dsize = s.size() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span>* _dest = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[_dsize];</span><br><span class="line">    wmemset(_dest, <span class="number">0x0</span>, _dsize);</span><br><span class="line">    mbstowcs_s(&amp;i, _dest, _dsize, _source, _dsize);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">wstring</span> result = _dest;</span><br><span class="line">    <span class="keyword">delete</span>[] _dest;</span><br><span class="line">    setlocale(LC_ALL, curLocale.c_str());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;codecvt&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ws2s</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; src )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::locale <span class="title">sys_locale</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">wchar_t</span>* data_from = src.c_str();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">wchar_t</span>* data_from_end = src.c_str() + src.size();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">wchar_t</span>* data_from_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> wchar_size = <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>);</span><br><span class="line">	<span class="keyword">char</span>* data_to = <span class="keyword">new</span> <span class="keyword">char</span>[(src.size() + <span class="number">1</span>) * wchar_size];</span><br><span class="line">	<span class="keyword">char</span>* data_to_end = data_to + (src.size() + <span class="number">1</span>) * wchar_size;</span><br><span class="line">	<span class="keyword">char</span>* data_to_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>( data_to, <span class="number">0</span>, (src.size() + <span class="number">1</span>) * wchar_size );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::codecvt&lt;<span class="keyword">wchar_t</span>, <span class="keyword">char</span>, <span class="keyword">mbstate_t</span>&gt; convert_facet;</span><br><span class="line">	<span class="keyword">mbstate_t</span> out_state = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> result = <span class="built_in">std</span>::use_facet&lt;convert_facet&gt;(sys_locale).out(</span><br><span class="line">		out_state, data_from, data_from_end, data_from_next,</span><br><span class="line">		data_to, data_to_end, data_to_next );</span><br><span class="line">	<span class="keyword">if</span>( result == convert_facet::ok )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> dst = data_to;</span><br><span class="line">		<span class="keyword">delete</span>[] data_to;</span><br><span class="line">		<span class="keyword">return</span> dst;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">"convert error!\n"</span> );</span><br><span class="line">		<span class="keyword">delete</span>[] data_to;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">s2ws</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; src )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::locale <span class="title">sys_locale</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* data_from = src.c_str();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* data_from_end = src.c_str() + src.size();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* data_from_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">wchar_t</span>* data_to = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[src.size() + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">wchar_t</span>* data_to_end = data_to + src.size() + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">wchar_t</span>* data_to_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	wmemset( data_to, <span class="number">0</span>, src.size() + <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::codecvt&lt;<span class="keyword">wchar_t</span>, <span class="keyword">char</span>, <span class="keyword">mbstate_t</span>&gt; convert_facet;</span><br><span class="line">	<span class="keyword">mbstate_t</span> in_state = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> result = <span class="built_in">std</span>::use_facet&lt;convert_facet&gt;(sys_locale).in(</span><br><span class="line">		in_state, data_from, data_from_end, data_from_next,</span><br><span class="line">		data_to, data_to_end, data_to_next );</span><br><span class="line">	<span class="keyword">if</span>( result == convert_facet::ok )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">wstring</span> dst = data_to;</span><br><span class="line">		<span class="keyword">delete</span>[] data_to;</span><br><span class="line">		<span class="keyword">return</span> dst;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">"convert error!\n"</span> );</span><br><span class="line">		<span class="keyword">delete</span>[] data_to;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>(<span class="string">L""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ws2utf8</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; src )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::wstring_convert&lt;<span class="built_in">std</span>::codecvt_utf8&lt;<span class="keyword">wchar_t</span>&gt;&gt; conv;</span><br><span class="line">	<span class="keyword">return</span> conv.to_bytes( src );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">utf8_2_ws</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; src )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::wstring_convert&lt;<span class="built_in">std</span>::codecvt_utf8&lt;<span class="keyword">wchar_t</span>&gt; &gt; conv;</span><br><span class="line">	<span class="keyword">return</span> conv.from_bytes( src );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/25/%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" itemprop="url">
                  纯虚析构函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T20:25:15+08:00">
                2020-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>纯虚函数将产生抽象类——不能实例化的类（即不能创建此类型的对象）。当你想使一个类成为抽象类，刚好又没有任何纯虚函数。该怎么做？</strong><br><strong>因为抽象类是准备被用做基类的，基类必须要有一个虚析构函数，纯虚函数会产生抽象类，所以方法很简单：在想要成为抽象类的类里声明一个纯虚析构函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBase</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~AbstractBase() = <span class="number">0</span>; <span class="comment">// 声明一个纯虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AbstractBase::~AbstractBase()&#123;&#125;<span class="comment">//必须在类外进行定义</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span><span class="keyword">public</span> AbstractBase</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AbstractBase * p = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 触发基类的析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个类有一个纯虚函数，所以它是抽象的，而且它有一个虚析构函数，所以不会产生析构函数问题。</p>
</blockquote>
<blockquote>
<p>这个定义是必需的，因为虚析构函数工作的方式是：最底层的派生类的析构函数最先被调用，然后各个基类的析构函数被调用。<br>这就是说，即使是抽象类，编译器也要产生对~AbstractBase的调用，但是，又由于父类的析构函数是纯虚函数，没有实现体，所以，当析构到父类时，由于没有实现体，所以导致父类无法析构，最终也导致了析构畸形，所以要保证为它提供函数体。如果不这么做，链接器就会检测出来。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/%E5%A5%87%E5%BC%82%E6%A8%A1%E6%9D%BF%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/18/%E5%A5%87%E5%BC%82%E6%A8%A1%E6%9D%BF%E9%80%92%E5%BD%92/" itemprop="url">
                  奇异模板递归
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-18T21:06:03+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-奇异模板递归"><a href="#C-奇异模板递归" class="headerlink" title="C++ 奇异模板递归"></a>C++ 奇异模板递归</h1><blockquote>
<p>奇异递归模板模式（curiously recurring template pattern，CRTP）是C++模板编程时的一种惯用法（idiom）：把派生类作为基类的模板参数。更一般地被称作F-bound polymorphism，是一类F 界量化，相关介绍可以参考 wiki 奇异递归模板模式。</p>
</blockquote>
<h2 id="CRTP的特点"><a href="#CRTP的特点" class="headerlink" title="CRTP的特点"></a>CRTP的特点</h2><ul>
<li>继承自模板类；</li>
<li>使用派生类作为模板参数特化基类；</li>
</ul>
<h2 id="CRTP基本范式"><a href="#CRTP基本范式" class="headerlink" title="CRTP基本范式"></a>CRTP基本范式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">// use the derived class itself as a template parameter of the base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;Derived&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样做的目的是在基类中使用派生类，从基类的角度来看，派生类其实也是基类，通过向下转换[downcast],因此，基类可以通过static_cast把其转换到派生类，从而使用派生类的成员，形式如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWhat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T&amp; derived = <span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// use derived...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 这里不使用dynamic_cast,因为dynamic_cast一般是为了确保在运行期(run-time)向上向下转换的正确性。CRTP的设计是：派生类就是基类的模板参数，因此static_cast足矣。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> :</span> <span class="keyword">public</span> Base&lt;Derived1&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> :</span> <span class="keyword">public</span> Base&lt;Derived1&gt; <span class="comment">// bug in this line of code</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建议这种写法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// import </span></span><br><span class="line">    Base()&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  The Curiously Recurring Template Pattern (CRTP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Expression</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">cast</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expands derived class interface by inheriting from the base class</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_absolute_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cast().set_value(<span class="built_in">abs</span>(cast().get_value()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cast().get_value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cast().get_result();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cast().sub_calc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Expression&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Expression&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Expression()&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Expression&lt;Square&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Square(<span class="keyword">double</span> val = <span class="number">0</span>, <span class="keyword">double</span> res = <span class="number">0</span>):val_(val),result_(res)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        val_ = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub_calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        result_ = val_*val_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> val_;</span><br><span class="line">    <span class="keyword">double</span> result_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sqrt</span> :</span> <span class="keyword">public</span> Expression&lt;Sqrt&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Sqrt(<span class="keyword">double</span> val = <span class="number">0</span>, <span class="keyword">double</span> res = <span class="number">0</span>) :val_(val), result_(res) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        val_ = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub_calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(val_&gt;=<span class="number">0</span>);</span><br><span class="line">        result_ = <span class="built_in">sqrt</span>(val_);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> val_;</span><br><span class="line">    <span class="keyword">double</span> result_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Static interfaces</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // <span class="title">T</span> <span class="title">is</span> <span class="title">deduced</span> <span class="title">at</span> <span class="title">compile</span>-<span class="title">time</span></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">OP</span>(<span class="title">Expression</span>&lt;T&gt; &amp;<span class="title">sq</span>, <span class="title">const</span> <span class="title">string</span>&amp; <span class="title">op</span>) &#123;</span></span><br><span class="line">    <span class="comment">// will do static dispatch</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Berfore OP this expression's value is:"</span> &lt;&lt; sq.value() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    sq.calc();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After OP "</span>&lt;&lt; op &lt;&lt;\</span><br><span class="line">        <span class="string">",  this expression's result is:"</span> &lt;&lt; sq.result() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Sqrt <span class="title">sqr</span><span class="params">(<span class="number">-2</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"this expression's value is:"</span> &lt;&lt; sqr.value() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// Adding functionality</span></span><br><span class="line">sqr.set_absolute_value();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After set absolute,  this expression's value is:"</span> &lt;&lt; sqr.value() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">OP(sqr, <span class="string">"Sqrt"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------\n"</span>;</span><br><span class="line"><span class="function">Square <span class="title">sq</span><span class="params">(<span class="number">-2</span>)</span></span>;</span><br><span class="line">OP(sq, <span class="string">"Square"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CRTP是一种静态多态（static polymorphism/Static binding/Compile-Time binding)与其对应的是动态多态(dynamic polymorphism/Dynamic binding/Run-Time binding)。<br>静态多态与和动态的区别是：多态是动态绑定（运行时绑定 run-time binding），CRTP是静态绑定（编译时绑定 compile-time binding）。其中，动态多态在实现多态时，需要重写虚函数，这种运行时绑定的操作往往需要查找虚表等，效率低。另，template的核心技术在于编译期多态机制，与运行期多态（runtime polymorphism）相比，这种动态机制提供想编译期多态性，给了程序运行期无可比拟的效率优势，因此，如果想在编译期确定通过基类来得到派生类的行为，CRTP便是一种绝佳的选择。</p>
</blockquote>
<p><em>std::enable_shared_from_this&lt;&gt;</em> 大法！！！ </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangyxin coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/17/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T20:14:59+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zhangyxin" />
          <p class="site-author-name" itemprop="name">zhangyxin</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangyxin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
